<!DOCTYPE html>
<html>
<head>
  <title>Flying Seal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!-- Подключаем шрифт Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { font-family: 'Press Start 2P', cursive; }
    html, body {
      margin: 0; padding: 0; box-sizing: border-box;
      background-color: #000;
      width: 100vw; height: 100vh; overflow: hidden;
    }
    body {
      padding-top: env(safe-area-inset-top);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
    }
    #gameCanvas {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      display: block;
      /* По умолчанию WINTER-тема */
      background: url('BACKGROUND/photo_2025-03-12_12-26-18.gif') center/cover no-repeat;
    }
    #coinContainer {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    #menu {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      color: white; display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 10;
    }
    #menu * { text-shadow: 2px 2px 4px #000; }
    #menu h1 { font-size: 5vw; margin-bottom: 10px; animation: bounce 2s infinite; }
    #greeting { font-size: 3vw; margin-bottom: 20px; }
    #startBtn, #shopBtn {
      padding: 10px 20px; font-size: 3vw; letter-spacing: 2px;
      text-transform: uppercase; color: #fff; background: #3498db;
      border: 4px solid #fff; box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer; margin-bottom: 15px; transition: all 0.1s;
    }
    #telegramBtn {
      margin-bottom: 15px; width: 80px; height: auto; cursor: pointer;
    }
    #score, #coinCount {
      position: absolute; color: white; font-size: 4vw; z-index: 5;
    }
    #score { top: 5%; left: 5%; }
    #coinCount {
      top: 5%; right: 5%;
      display: none; align-items: center;
    }
    #coinCount img {
      height: 4vw; margin-right: 5px;
    }
    .pixelButton {
      padding: 10px 20px; font-size: 3vw; letter-spacing: 2px;
      text-transform: uppercase; color: #fff; background: #3498db;
      border: 4px solid #fff; box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer; transition: all 0.1s; user-select: none;
    }
    button:active {
      box-shadow: 2px 2px 0 #00ffff;
      transform: translate(2px, 2px);
    }
    #shop {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.8)),
                  url('BACKGROUND/photo_2025-03-12_12-26-18.gif') center/cover no-repeat;
      color: white; display: none; flex-direction: column;
      align-items: center; overflow-y: auto; padding: 10px; z-index: 30;
    }
    #shop h2 { font-size: 5vw; margin-bottom: 20px; }
    #shopBalance { font-size: 3vw; margin-bottom: 20px; }
    .shop-grid {
      display: grid; grid-template-columns: repeat(3, 1fr);
      gap: 10px; width: 100%;
    }
    .shop-item {
      background: #3498db; border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff; padding: 5px;
      text-align: center; image-rendering: pixelated;
    }
    .shop-item img {
      width: 100%; image-rendering: pixelated; margin-bottom: 5px;
    }
    .shop-item button { margin-top: 5px; }
    #shop .back-btn {
      margin-top: 20px; background: #FF5722;
      border: 4px solid #fff; box-shadow: 4px 4px 0 #00ffff;
      font-size: 3vw; padding: 10px 20px; cursor: pointer;
    }
    #gameOverOverlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); color: white;
      display: none; flex-direction: column; justify-content: center;
      align-items: center; text-align: center; z-index: 20;
    }
    #pauseMenu {
      display: none; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8); color: white; text-align: center;
      padding: 20px; z-index: 30; width: 80%; max-width: 400px;
    }
    /* Модальное окно выбора темы */
    #themeSelectModal {
      display: none; 
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); z-index: 60;
      flex-direction: column; justify-content: center; align-items: center;
      color: #fff;
    }
    #themeSelectModal button {
      padding: 10px 20px; font-size: 3vw; margin: 10px;
      letter-spacing: 2px; text-transform: uppercase;
      color: #fff; background: #3498db;
      border: 4px solid #fff; box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer; transition: all 0.1s;
    }
    #modeSelectModal {
      display: none; position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); z-index: 50;
      flex-direction: column; justify-content: center;
      align-items: center; color: #fff;
    }
    #modeSelectModal button {
      padding: 10px 20px; font-size: 3vw; margin: 10px;
      letter-spacing: 2px; text-transform: uppercase;
      color: #fff; background: #3498db;
      border: 4px solid #fff; box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer; transition: all 0.1s;
    }
    #hardModeDescription {
      position: absolute; top: 20%; left: 50%;
      transform: translateX(-50%);
      background: #3498db; border: 4px solid #fff;
      padding: 20px; z-index: 50; font-size: 3vw;
      display: none; text-align: center; width: 80%;
    }
    #hardModeDescription button {
      position: absolute; top: 5px; right: 5px;
      background: transparent; border: none;
      font-size: 3vw; color: #fff; cursor: pointer;
    }
    #hardModeDescription p { margin: 0; }
    #profileBtn {
      position: absolute; top: 50px; left: 5px;
      width: 60px; height: 60px; border-radius: 50%;
      border: 4px solid #fff; background: #3498db;
      cursor: pointer; z-index: 60; display: block;
      overflow: hidden;
    }
    #profileBtn img {
      width: 100%; height: 100%; object-fit: cover;
    }
    #profileModal {
      display: none; position: fixed; top: 50%;
      left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95); border: 4px solid #fff;
      padding: 20px; z-index: 80; color: #fff;
      text-align: center; width: 80%; max-width: 400px;
    }
    #profileModal h2 { margin-bottom: 15px; font-size: 5vw; }
    #avatarSelection {
      display: flex; justify-content: center;
      gap: 10px; margin-bottom: 15px;
    }
    #avatarSelection img {
      width: 50px; height: 50px; border-radius: 50%;
      border: 3px solid transparent; cursor: pointer;
    }
    #avatarSelection img.selected { border-color: #e67e22; }
    #nicknameSection {
      display: flex; justify-content: center;
      align-items: center; gap: 10px; margin-bottom: 15px;
    }
    #nicknameSection span { font-size: 4vw; }
    #editNickname { cursor: pointer; font-size: 4vw; }
    #closeProfileModal {
      padding: 5px 10px; font-size: 3vw;
      color: #fff; background: #e74c3c;
      border: 4px solid #fff; box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer;
    }
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-20px); }
      60% { transform: translateY(-10px); }
    }
    #platformerControls {
      display: none; position: absolute;
      bottom: 20px; left: 0; right: 0; padding: 0 20px;
      z-index: 100; display: flex;
      justify-content: space-between; align-items: center;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="coinContainer"></div>
  
  <button id="profileBtn">
    <img id="currentAvatar" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='45' fill='%23ff0000'/></svg>" alt="avatar">
  </button>
  <button id="platformerPauseBtn" style="position: absolute; top: 120px; right: 10px; display: none;">||</button>
  
  <div id="profileModal">
    <h2>Profile</h2>
    <div id="avatarSelection">
      <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='45' fill='%23ff0000'/></svg>" alt="avatar1" data-avatar="red" class="selected">
      <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><rect x='10' y='10' width='80' height='80' fill='%2300ff00'/></svg>" alt="avatar2" data-avatar="green">
      <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><polygon points='50,5 95,95 5,95' fill='%230000ff'/></svg>" alt="avatar3" data-avatar="blue">
    </div>
    <div id="nicknameSection">
      <span id="nicknameDisplay">Guest</span>
      <span id="editNickname">&#9998;</span>
    </div>
    <p id="levelText">Level: 0</p>
    <p id="xpText">XP: 0 / 100</p>
    <button id="closeProfileModal">Close</button>
  </div>
  
  <div id="howToPlayOverlay">
    <h2>HOW TO PLAY?</h2>
    <p>Use left/right arrow keys to move,<br>press up arrow or space to jump!</p>
    <p>(Tap or click anywhere to start)</p>
  </div>
  
  <div id="menu">
    <h1 id="gameTitle">FLYING SEAL</h1>
    <p id="greeting"></p>
    <button id="startBtn">PLAY</button>
    <button id="shopBtn">SHOP</button>
    <img id="telegramBtn" src="BACKGROUND/telegrammm.png" alt="Telegram">
    <div id="leaderboard" style="display:none;">
      <h3>High Scores</h3>
      <ul id="topScores"></ul>
    </div>
  </div>

  <!-- Модальное окно выбора темы -->
  <div id="themeSelectModal">
    <h2>Select Theme</h2>
    <button id="winterThemeBtn">WINTER</button>
    <button id="jungleThemeBtn">JUNGLE</button>
  </div>

  <div id="modeSelectModal">
    <h2>Select Mode</h2>
    <button id="flyingModeBtn">FLYING</button>
    <button id="platformerModeBtn">PLATFORMER</button>
    <button id="dunkModeBtn">DUNK</button>
  </div>

  <div id="hardModeDescription">
    <button id="closeHardModeDesc">X</button>
    <p>HARD MODE: Narrow gaps and double coins!</p>
  </div>

  <div id="shop">
    <h2>Shop</h2>
    <p id="shopBalance">Total Coins: 0</p>
    <div id="shopItems"></div>
    <button class="back-btn" id="shopBackBtn">Back</button>
  </div>

  <div id="gameOverOverlay">
    <h2>Share the result with your friends!</h2>
    <button id="shareBtn" class="pixelButton">Share the result!</button>
    <button id="continueBtn" class="pixelButton">Continue game!</button>
    <button id="mainMenuBtn" class="pixelButton">MAIN MENU</button>
  </div>

  <div id="pauseMenu">
    <h2>Paused</h2>
    <button id="resumeBtn" class="pixelButton">Resume</button>
    <button id="exitBtn" class="pixelButton">Main Menu</button>
  </div>

  <div id="platformerControls">
    <button id="btnLeft" class="pixelButton">←</button>
    <button id="btnUp" class="pixelButton">↑</button>
    <button id="btnRight" class="pixelButton">→</button>
  </div>

  <div id="score"></div>
  <div id="coinCount">
    <img src="BACKGROUND/goldcoin.gif" alt="coin">
    <span id="coinText">0</span>
  </div>

  <script>
    // ------------------------------- Общие переменные и функции --------------------------------
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('platformerControls').style.display = 'none';
    });

    let userNickname = localStorage.getItem("userNickname") || "Guest";
    let userAvatar = localStorage.getItem("userAvatar") || "red";

    function updateProfileDisplay() {
      document.getElementById("nicknameDisplay").textContent = userNickname;
      let avatarImg;
      if (userAvatar === "red") {
        avatarImg = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='45' fill='%23ff0000'/></svg>";
      } else if (userAvatar === "green") {
        avatarImg = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><rect x='10' y='10' width='80' height='80' fill='%2300ff00'/></svg>";
      } else if (userAvatar === "blue") {
        avatarImg = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><polygon points='50,5 95,95 5,95' fill='%230000ff'/></svg>";
      }
      document.getElementById("currentAvatar").src = avatarImg;
      document.querySelectorAll("#avatarSelection img").forEach(img => {
        if (img.getAttribute("data-avatar") === userAvatar) img.classList.add("selected");
        else img.classList.remove("selected");
      });
    }

    document.getElementById("editNickname").addEventListener("click", () => {
      let newNick = prompt("Enter your new nickname:", userNickname);
      if(newNick !== null && newNick.trim() !== ""){
        userNickname = newNick.trim();
        localStorage.setItem("userNickname", userNickname);
        updateProfileDisplay();
      }
    });

    document.querySelectorAll("#avatarSelection img").forEach(img => {
      img.addEventListener("click", () => {
        userAvatar = img.getAttribute("data-avatar");
        localStorage.setItem("userAvatar", userAvatar);
        updateProfileDisplay();
      });
    });

    document.getElementById("profileBtn").addEventListener("click", () => {
      document.getElementById("profileModal").style.display = "block";
      updateProfileDisplay();
      updateLevelInfoDisplay();
    });

    document.getElementById("closeProfileModal").addEventListener("click", () => {
      document.getElementById("profileModal").style.display = "none";
    });

    let userLevel = parseInt(localStorage.getItem("userLevel") || "0");
    let userXP = parseInt(localStorage.getItem("userXP") || "0");
    const xpThreshold = 100;
    function updateLevelInfoDisplay() {
      document.getElementById("levelText").textContent = "Level: " + userLevel;
      document.getElementById("xpText").textContent = "XP: " + userXP + " / " + xpThreshold;
    }
    function addXP(points) {
      userXP += points;
      while (userXP >= xpThreshold) {
        userXP -= xpThreshold;
        userLevel++;
      }
      localStorage.setItem("userLevel", userLevel);
      localStorage.setItem("userXP", userXP);
      updateLevelInfoDisplay();
    }

    let platformerLevel = 1;
    let pipes = [];
    let pipeSpeed = 2;
    let pipeWidth = 75;
    const pipeImage = new Image(); 
    pipeImage.src = 'BACKGROUND/PIPE.png';
    // Для режима JUNGLE загружаем две трубы:
    const pipeImageJungle1 = new Image();
    pipeImageJungle1.src = 'BACKGROUND/PIPE 1.png';
    const pipeImageJungle2 = new Image();
    pipeImageJungle2.src = 'BACKGROUND/PIPE 2.png';
    
    let flyingPipeCounter = 0;
    
    const platformImage = new Image(); platformImage.src = 'BACKGROUND/platform.png';
    let collisionOffsetLeft = 10, collisionOffsetRight = 10, collisionOffsetTop = 20, collisionOffsetBottom = 20;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const shop = document.getElementById('shop');
    const shopItemsDiv = document.getElementById('shopItems');
    const shopBackBtn = document.getElementById('shopBackBtn');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const shopBtn = document.getElementById('shopBtn');
    const telegramBtn = document.getElementById('telegramBtn');
    const shareBtn = document.getElementById('shareBtn');
    const continueBtn = document.getElementById('continueBtn');
    const mainMenuBtn = document.getElementById('mainMenuBtn');
    const topScoresList = document.getElementById('topScores');
    const hardModeDescription = document.getElementById('hardModeDescription');
    const closeHardModeDesc = document.getElementById('closeHardModeDesc');
    const scoreElement = document.getElementById('score');
    const coinCountElement = document.getElementById('coinCount');
    const modeSelectModal = document.getElementById('modeSelectModal');
    const flyingModeBtn = document.getElementById('flyingModeBtn');
    const platformerModeBtn = document.getElementById('platformerModeBtn');
    const dunkModeBtn = document.getElementById('dunkModeBtn');
    const platformerPauseBtn = document.getElementById('platformerPauseBtn');
    const pauseMenu = document.getElementById("pauseMenu");
    const platformerControls = document.getElementById("platformerControls");
    const themeSelectModal = document.getElementById("themeSelectModal");
    let gameStarted = false, score = 0, coinCount = 0;
    let paused = false;
    let totalCoins = parseInt(localStorage.getItem("totalCoins") || "0");
    let usernameGame = (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe &&
                        window.Telegram.WebApp.initDataUnsafe.user &&
                        window.Telegram.WebApp.initDataUnsafe.user.username)
                       ? window.Telegram.WebApp.initDataUnsafe.user.username 
                       : "Guest";
    let hardModeEnabled = false, selectedMode = "FLYING";
    let purchasedTrails = JSON.parse(localStorage.getItem("purchasedTrails") || '["1"]');
    let currentTrailId = localStorage.getItem("selectedTrail") || "1";
    const standardSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%230000ff'/></svg>";
    const pixelFrostSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%23a0e9ff'/></svg>";
    const neonPulseSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%23ff00ff'/></svg>";
    const retroArcadeSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%23ffff00'/></svg>";
    const pipeDesigns = {
      "0": { id: "0", name: "Standard", price: 0, preview: standardSVG, colors: ["#0000ff"], animation: "none" },
      "1": { id: "1", name: "Pixel Frost", price: 25, preview: pixelFrostSVG, colors: ["#a0e9ff"], animation: "blink" },
      "2": { id: "2", name: "Neon Pulse", price: 50, preview: neonPulseSVG, colors: ["#ff00ff"], animation: "pulse" },
      "3": { id: "3", name: "Retro Arcade", price: 100, preview: retroArcadeSVG, colors: ["#ffff00"], animation: "glow" }
    };
    let purchasedPipeDesigns = JSON.parse(localStorage.getItem("purchasedPipeDesigns") || '["0"]');
    let currentPipeDesign = localStorage.getItem("selectedPipeDesign") || (purchasedPipeDesigns.length > 0 ? purchasedPipeDesigns[0] : "0");
    const shopBalance = document.getElementById('shopBalance');
    shopBalance.textContent = `Total Coins: ${totalCoins}`;
    let particles = [], coins = [], reactionMessages = [];

    /* ====== Загрузка изображений персонажей (используем seal для обоих режимов) ====== */
    const sealJump = new Image(); sealJump.src = 'BACKGROUND/seal jump.png';
    const sealFall = new Image(); sealFall.src = 'BACKGROUND/seal fall.png';
    let currentCharacterJump = sealJump;
    let currentCharacterFall = sealFall;
    let selectedTheme = "WINTER";

    // Загружаем "листочек" через встроенное SVG (пиксельный стиль)
    const leafImg = new Image();
    leafImg.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20'%3E%3Cpolygon points='10,0 15,10 10,20 5,10' fill='%234CAF50'/%3E%3C/svg%3E";
    let leafParticles = [];
    function spawnLeaf() {
      let leaf = {
        x: Math.random() * canvas.width,
        y: -20,
        size: Math.random() * 10 + 10,
        speedY: Math.random() * 0.5 + 0.5,
        speedX: Math.random() * 0.4 - 0.2,
        rotation: Math.random() * 2 * Math.PI,
        rotationSpeed: (Math.random() - 0.5) * 0.02
      };
      leafParticles.push(leaf);
    }
    function updateLeafParticles() {
      for (let i = leafParticles.length - 1; i >= 0; i--) {
        let leaf = leafParticles[i];
        leaf.y += leaf.speedY;
        leaf.x += leaf.speedX;
        leaf.rotation += leaf.rotationSpeed;
        if (leaf.y > canvas.height + leaf.size) {
          leafParticles.splice(i, 1);
        }
      }
    }
    function drawLeafParticles() {
      leafParticles.forEach(leaf => {
        ctx.save();
        ctx.translate(leaf.x, leaf.y);
        ctx.rotate(leaf.rotation);
        ctx.drawImage(leafImg, -leaf.size/2, -leaf.size/2, leaf.size, leaf.size);
        ctx.restore();
      });
    }

    // Новый режим DUNK (DUNK SHOT) – бесконечный режим с кольцами, где игрок падает и попадает в кольцо,
    // после чего генерируется новое кольцо сверху, а камера двигается вверх.
    let dunkScore = 0;
    let dunkPlayer = { x: 0, y: 0, width: 50, height: 50, vx: 0, vy: 0 };
    let currentRing = null; // текущее кольцо
    let gravity = 0.5;
    let ringRadius = 40;
    let ringXMin = ringRadius;
    let ringXMax = canvas ? canvas.width - ringRadius : 800;  // если canvas не инициализирован, берем 800
    let cameraOffset = 0;
    function spawnInitialRing() {
      // Создадим кольцо в центре экрана по вертикали
      currentRing = { x: canvas.width / 2, y: canvas.height / 2, radius: ringRadius };
    }
    function spawnNewRing() {
      // Новое кольцо генерируется выше предыдущего на случайном расстоянии
      let newY = currentRing.y - (Math.random() * 100 + 150);
      let newX = Math.random() * (canvas.width - 2 * ringRadius) + ringRadius;
      currentRing = { x: newX, y: newY, radius: ringRadius };
    }
    function startDunkMode() {
      // Инициализация режима DUNK
      // Сбросим камеру и счет
      cameraOffset = 0;
      dunkScore = 0;
      // Инициализируем игрока: пусть появляется чуть выше нижней части экрана
      dunkPlayer = { 
        x: canvas.width / 2 - 25, 
        y: canvas.height - 100, 
        width: 50, 
        height: 50, 
        vx: 0, 
        vy: 0 
      };
      spawnInitialRing();
      // Добавим обработку клавиш для горизонтального движения
      window.addEventListener("keydown", dunkKeyDown);
      window.addEventListener("keyup", dunkKeyUp);
      dunkModeLoop();
    }
    let dunkKeys = {};
    function dunkKeyDown(e) {
      dunkKeys[e.code] = true;
    }
    function dunkKeyUp(e) {
      dunkKeys[e.code] = false;
    }
    function dunkModeLoop() {
      if (paused) return;
      clearCanvas();
      // Обновляем позиции игрока
      // Горизонтальное управление:
      if (dunkKeys["ArrowLeft"]) {
        dunkPlayer.vx = -3;
      } else if (dunkKeys["ArrowRight"]) {
        dunkPlayer.vx = 3;
      } else {
        dunkPlayer.vx = 0;
      }
      dunkPlayer.x += dunkPlayer.vx;
      // Применяем гравитацию
      dunkPlayer.vy += gravity;
      dunkPlayer.y += dunkPlayer.vy;
      // Проверяем столкновение игрока с кольцом (имитируем, что игрок падает в кольцо)
      // Если нижняя граница игрока находится в пределах кольца (с небольшим допуском)
      if (dunkPlayer.y + dunkPlayer.height >= currentRing.y - currentRing.radius &&
          dunkPlayer.y + dunkPlayer.height <= currentRing.y + currentRing.radius &&
          dunkPlayer.x + dunkPlayer.width/2 >= currentRing.x - currentRing.radius &&
          dunkPlayer.x + dunkPlayer.width/2 <= currentRing.x + currentRing.radius) {
        // Засчитываем "данк"
        dunkScore++;
        // Сброс вертикальной скорости для "прилегания" к кольцу
        dunkPlayer.vy = 0;
        // Генерируем новое кольцо выше
        spawnNewRing();
        // Сдвигаем камеру: увеличиваем offset на разницу, чтобы игрок остался на экране
        cameraOffset += 150;
      }
      // Применяем эффект скроллинга: сдвигаем всё вверх
      ctx.save();
      ctx.translate(0, cameraOffset);
      // Рисуем кольцо
      drawRing();
      // Рисуем игрока
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(dunkPlayer.x, dunkPlayer.y, dunkPlayer.width, dunkPlayer.height);
      ctx.restore();
      // Отрисовываем другие объекты (например, счет)
      scoreElement.textContent = `Dunk Score: ${dunkScore}`;
      // Если игрок улетел за пределы экрана сверху или снизу, конец игры
      if (dunkPlayer.y - cameraOffset > canvas.height || dunkPlayer.y - cameraOffset + dunkPlayer.height < 0) {
        gameOverOverlay.style.display = 'block';
        window.removeEventListener("keydown", dunkKeyDown);
        window.removeEventListener("keyup", dunkKeyUp);
        return;
      }
      requestAnimationFrame(dunkModeLoop);
    }
    function drawRing() {
      // Отрисовка кольца в пиксельном стиле (имитируем игру Dunk Shot)
      ctx.save();
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(currentRing.x, currentRing.y, currentRing.radius, 0, Math.PI * 2);
      ctx.stroke();
      // Добавим небольшие пиксельные детали (например, две перекладины)
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(currentRing.x - currentRing.radius, currentRing.y);
      ctx.lineTo(currentRing.x + currentRing.radius, currentRing.y);
      ctx.moveTo(currentRing.x, currentRing.y - currentRing.radius);
      ctx.lineTo(currentRing.x, currentRing.y + currentRing.radius);
      ctx.stroke();
      ctx.restore();
    }

    /* ========= FLYING MODE ========= */
    let shadow = null;
    function startFlyingMode() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      coins = [];
      pipes = [];
      particles = [];
      reactionMessages = [];
      scoreElement.style.display = 'block';
      coinCountElement.style.display = 'flex';
      nerpaImg = shadow && (shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall);
      shadow = {
        x: canvas.width * 0.1,
        y: canvas.height * 0.5,
        width: canvas.width * 0.1,
        height: canvas.width * 0.1,
        velocity: 0,
        gravity: 0.35,
        jump: -6
      };
      canvas.addEventListener("mousedown", flyJump);
      canvas.addEventListener("touchstart", flyJumpTouch);
      flyingGameLoop();
    }
    function flyJump(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyJumpTouch(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyingGameLoop() {
      if (!gameStarted || paused) return;
      clearCanvas();
      shadow.velocity += shadow.gravity;
      shadow.y += shadow.velocity;
      spawnParticle(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      updateParticles();
      if(selectedTheme === "JUNGLE"){
        if(Math.random() < 0.02) {
          spawnLeaf();
        }
        updateLeafParticles();
        drawLeafParticles();
      }
      if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (canvas.width * 0.5)) {
        createPipe();
      }
      for (let pipe of pipes) {
        pipe.x -= pipeSpeed;
        if (!pipe.passed && pipe.x + pipeWidth < shadow.x) {
          score++;
          pipe.passed = true;
          if (score % 10 === 0) { showReaction('Score ' + score); }
        }
        if (checkCollision(pipe) || shadow.y < 0 || shadow.y + shadow.height > canvas.height) {
          clearCanvas();
          gameStarted = false;
          removeAllCoins();
          scoreElement.style.display = 'none';
          coinCountElement.style.display = 'none';
          addXP(score);
          setTimeout(() => {
            saveScore(usernameGame, score);
            gameOverOverlay.style.display = 'block';
          }, 1000);
          return;
        }
      }
      coins.forEach(coin => {
        coin.x -= pipeSpeed;
        if (!coin.collected && checkCoinCollision(coin)) {
          coin.collected = true;
          coinCount++;
          totalCoins++;
          localStorage.setItem("totalCoins", totalCoins);
          shopBalance.textContent = `Total Coins: ${totalCoins}`;
        }
      });
      updateCoins();
      drawParticles();
      updateShadowImage();
      ctx.save();
      ctx.translate(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      let angle = shadow.velocity < 0 ? -15 * Math.PI/180 : 15 * Math.PI/180;
      ctx.rotate(angle);
      let img = shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall;
      ctx.drawImage(img, -shadow.width/2, -shadow.height/2, shadow.width, shadow.height);
      ctx.restore();
      drawPipes();
      scoreElement.textContent = `Score: ${score}`;
      document.getElementById('coinText').textContent = coinCount;
      drawReactions();
      requestAnimationFrame(flyingGameLoop);
    }
    function drawPipes() {
      pipes.forEach(pipe => {
        ctx.save();
        ctx.translate(pipe.x + pipeWidth / 2, pipe.topHeight);
        ctx.scale(1, -1);
        ctx.drawImage(pipe.pipeImg, -pipeWidth/2, 0, pipeWidth, pipe.topHeight);
        ctx.restore();
        ctx.drawImage(pipe.pipeImg, pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
      });
    }
    function createPipe() {
      let gap = hardModeEnabled ? canvas.height * 0.25 : canvas.height * 0.3;
      const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;
      let pipeImg;
      if(selectedTheme === "JUNGLE"){
        pipeImg = (Math.random() < 0.6) ? pipeImageJungle1 : pipeImageJungle2;
      } else {
        pipeImg = pipeImage;
      }
      let design = (currentPipeDesign !== "0" && pipeDesigns[currentPipeDesign]) ? pipeDesigns[currentPipeDesign] : null;
      let color = design ? design.colors[0] : "#fff";
      pipes.push({
        x: canvas.width,
        topHeight: gapPosition,
        bottomY: gapPosition + gap,
        passed: false,
        color: color,
        design: design,
        pipeImg: pipeImg
      });
      if(selectedMode === "FLYING") {
        flyingPipeCounter++;
        if (flyingPipeCounter % 5 === 0) {
          createCoin(gapPosition, gap);
        }
      }
    }
    function checkCollision(pipe) {
      let topPipeLeft = pipe.x + collisionOffsetLeft;
      let topPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let topPipeBottom = pipe.topHeight - collisionOffsetTop;
      let bottomPipeLeft = pipe.x + collisionOffsetLeft;
      let bottomPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let bottomPipeTop = pipe.bottomY + collisionOffsetBottom;
      let playerLeft = shadow.x;
      let playerRight = shadow.x + shadow.width;
      let playerTop = shadow.y;
      let playerBottom = shadow.y + shadow.height;
      let collidesTop =
        playerRight > topPipeLeft &&
        playerLeft < topPipeRight &&
        playerTop < topPipeBottom;
      let collidesBottom =
        playerRight > bottomPipeLeft &&
        playerLeft < bottomPipeRight &&
        playerBottom > bottomPipeTop;
      return collidesTop || collidesBottom;
    }
    function createCoin(gapPosition, gapSize) {
      let coin = {
        x: canvas.width + pipeWidth / 2,
        y: gapPosition + gapSize / 2,
        radius: canvas.width * 0.03,
        collected: false
      };
      let coinEl = document.createElement('img');
      coinEl.src = 'BACKGROUND/goldcoin.gif';
      coinEl.style.position = 'absolute';
      coinEl.style.pointerEvents = 'none';
      coinEl.style.left = (coin.x - coin.radius) + "px";
      coinEl.style.top = (coin.y - coin.radius) + "px";
      coinEl.style.width = (coin.radius * 2) + "px";
      coinEl.style.height = (coin.radius * 2) + "px";
      document.getElementById('coinContainer').appendChild(coinEl);
      coin.el = coinEl;
      coins.push(coin);
    }
    function updateCoins() {
      coins.forEach((coin, index) => {
        if (!coin.collected) {
          coin.el.style.left = (coin.x - coin.radius) + "px";
          coin.el.style.top = (coin.y - coin.radius) + "px";
        } else {
          coin.el.remove();
          coins.splice(index, 1);
        }
      });
    }
    function removeAllCoins() {
      coins.forEach(coin => { if (coin.el) { coin.el.remove(); } });
      coins = [];
    }
    function checkCoinCollision(coin) {
      let cx = coin.x, cy = coin.y;
      let rx = shadow.x, ry = shadow.y;
      let rw = shadow.width, rh = shadow.height;
      let nearestX = Math.max(rx, Math.min(cx, rx + rw));
      let nearestY = Math.max(ry, Math.min(cy, ry + rh));
      let dx = cx - nearestX;
      let dy = cy - nearestY;
      return (dx * dx + dy * dy) < (coin.radius * coin.radius);
    }
    function spawnParticle(x, y) {
      particles.push({ x: x, y: y, size: Math.random() * 4 + 4, alpha: 1, decay: Math.random() * 0.03 + 0.01 });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function showReaction(message) {
      reactionMessages.push({ text: message, timer: 120, x: canvas.width / 2, y: canvas.height / 2 });
    }
    function drawReactions() {
      reactionMessages.forEach((msg, index) => {
        ctx.save();
        ctx.font = "20px 'Press Start 2P'";
        ctx.globalAlpha = msg.timer / 120;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.text, msg.x, msg.y);
        ctx.restore();
        msg.timer--;
        if (msg.timer <= 0) {
          reactionMessages.splice(index, 1);
        }
      });
    }
    function saveScore(name, points) {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      scores.push({ name, points });
      scores.sort((a, b) => b.points - a.points);
      scores = scores.slice(0, 5);
      localStorage.setItem("scores", JSON.stringify(scores));
      updateLeaderboard();
    }
    function updateLeaderboard() {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      topScoresList.innerHTML = scores.map(s => `<li>${s.name}: ${s.points}</li>`).join("");
    }
    updateLeaderboard();

    /* ================= Режим DUNK (Dunk Shot) ================= */
    // В этом режиме игрок падает вниз, пытаясь "влететь" в кольцо.
    // Если попадание успешно, генерируется новое кольцо выше, а камера смещается вверх.
    let dunkModeActive = false;
    let cameraOffset = 0;
    function spawnInitialRing() {
      currentRing = { x: canvas.width / 2, y: canvas.height / 2, radius: ringRadius };
    }
    let currentRing = null;
    let ringRadius = 40;
    function spawnNewRing() {
      let newY = currentRing.y - (Math.random() * 100 + 150);
      let newX = Math.random() * (canvas.width - 2 * ringRadius) + ringRadius;
      currentRing = { x: newX, y: newY, radius: ringRadius };
    }
    function startDunkMode() {
      dunkModeActive = true;
      cameraOffset = 0;
      dunkScore = 0;
      // Инициализируем игрока в нижней части экрана
      dunkPlayer = { 
        x: canvas.width / 2 - 25, 
        y: canvas.height - 100, 
        width: 50, 
        height: 50, 
        vx: 0, 
        vy: 0 
      };
      // Устанавливаем гравитацию и сбрасываем вертикальную скорость
      dunkPlayer.vy = 0;
      gravity = 0.5;
      spawnInitialRing();
      window.addEventListener("keydown", dunkKeyDown);
      window.addEventListener("keyup", dunkKeyUp);
      dunkModeLoop();
    }
    let dunkKeys = {};
    function dunkKeyDown(e) {
      dunkKeys[e.code] = true;
    }
    function dunkKeyUp(e) {
      dunkKeys[e.code] = false;
    }
    function dunkModeLoop() {
      if (!dunkModeActive || paused) return;
      clearCanvas();
      
      // Управление игроком по горизонтали
      if (dunkKeys["ArrowLeft"]) {
        dunkPlayer.vx = -3;
      } else if (dunkKeys["ArrowRight"]) {
        dunkPlayer.vx = 3;
      } else {
        dunkPlayer.vx = 0;
      }
      dunkPlayer.x += dunkPlayer.vx;
      // Применяем гравитацию
      dunkPlayer.vy += gravity;
      dunkPlayer.y += dunkPlayer.vy;
      
      // Проверяем столкновение: если нижняя часть игрока попадает в область кольца, считаем попадание
      if (dunkPlayer.y + dunkPlayer.height >= currentRing.y - currentRing.radius &&
          dunkPlayer.y + dunkPlayer.height <= currentRing.y + currentRing.radius &&
          dunkPlayer.x + dunkPlayer.width/2 >= currentRing.x - currentRing.radius &&
          dunkPlayer.x + dunkPlayer.width/2 <= currentRing.x + currentRing.radius) {
        dunkScore++;
        // Перемещаем игрока на кольцо (для визуального эффекта)
        dunkPlayer.y = currentRing.y - currentRing.radius - dunkPlayer.height;
        dunkPlayer.vy = 0;
        spawnNewRing();
        // Сдвигаем камеру вверх
        cameraOffset += 150;
      }
      // Применяем эффект скроллинга: сдвигаем всё вверх на cameraOffset
      ctx.save();
      ctx.translate(0, cameraOffset);
      // Отрисовываем кольцо
      drawRing();
      // Отрисовываем игрока
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(dunkPlayer.x, dunkPlayer.y, dunkPlayer.width, dunkPlayer.height);
      ctx.restore();
      scoreElement.textContent = `Dunk Score: ${dunkScore}`;
      
      // Если игрок опустился ниже или поднялся за экран, завершаем игру
      if (dunkPlayer.y - cameraOffset > canvas.height || dunkPlayer.y - cameraOffset + dunkPlayer.height < 0) {
        gameOverOverlay.style.display = 'block';
        window.removeEventListener("keydown", dunkKeyDown);
        window.removeEventListener("keyup", dunkKeyUp);
        return;
      }
      requestAnimationFrame(dunkModeLoop);
    }
    function drawRing() {
      ctx.save();
      // Рисуем кольцо в пиксельном стиле
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(currentRing.x, currentRing.y, currentRing.radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(currentRing.x - currentRing.radius, currentRing.y);
      ctx.lineTo(currentRing.x + currentRing.radius, currentRing.y);
      ctx.moveTo(currentRing.x, currentRing.y - currentRing.radius);
      ctx.lineTo(currentRing.x, currentRing.y + currentRing.radius);
      ctx.stroke();
      ctx.restore();
    }

    /* ================= Остальные режимы остаются без изменений ================= */
    let shadow = null;
    function startFlyingMode() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      coins = [];
      pipes = [];
      particles = [];
      reactionMessages = [];
      scoreElement.style.display = 'block';
      coinCountElement.style.display = 'flex';
      nerpaImg = shadow && (shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall);
      shadow = {
        x: canvas.width * 0.1,
        y: canvas.height * 0.5,
        width: canvas.width * 0.1,
        height: canvas.width * 0.1,
        velocity: 0,
        gravity: 0.35,
        jump: -6
      };
      canvas.addEventListener("mousedown", flyJump);
      canvas.addEventListener("touchstart", flyJumpTouch);
      flyingGameLoop();
    }
    function flyJump(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyJumpTouch(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyingGameLoop() {
      if (!gameStarted || paused) return;
      clearCanvas();
      shadow.velocity += shadow.gravity;
      shadow.y += shadow.velocity;
      spawnParticle(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      updateParticles();
      if(selectedTheme === "JUNGLE"){
        if(Math.random() < 0.02) {
          spawnLeaf();
        }
        updateLeafParticles();
        drawLeafParticles();
      }
      if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (canvas.width * 0.5)) {
        createPipe();
      }
      for (let pipe of pipes) {
        pipe.x -= pipeSpeed;
        if (!pipe.passed && pipe.x + pipeWidth < shadow.x) {
          score++;
          pipe.passed = true;
          if (score % 10 === 0) { showReaction('Score ' + score); }
        }
        if (checkCollision(pipe) || shadow.y < 0 || shadow.y + shadow.height > canvas.height) {
          clearCanvas();
          gameStarted = false;
          removeAllCoins();
          scoreElement.style.display = 'none';
          coinCountElement.style.display = 'none';
          addXP(score);
          setTimeout(() => {
            saveScore(usernameGame, score);
            gameOverOverlay.style.display = 'block';
          }, 1000);
          return;
        }
      }
      coins.forEach(coin => {
        coin.x -= pipeSpeed;
        if (!coin.collected && checkCoinCollision(coin)) {
          coin.collected = true;
          coinCount++;
          totalCoins++;
          localStorage.setItem("totalCoins", totalCoins);
          shopBalance.textContent = `Total Coins: ${totalCoins}`;
        }
      });
      updateCoins();
      drawParticles();
      updateShadowImage();
      ctx.save();
      ctx.translate(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      let angle = shadow.velocity < 0 ? -15 * Math.PI/180 : 15 * Math.PI/180;
      ctx.rotate(angle);
      let img = shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall;
      ctx.drawImage(img, -shadow.width/2, -shadow.height/2, shadow.width, shadow.height);
      ctx.restore();
      drawPipes();
      scoreElement.textContent = `Score: ${score}`;
      document.getElementById('coinText').textContent = coinCount;
      drawReactions();
      requestAnimationFrame(flyingGameLoop);
    }
    function drawPipes() {
      pipes.forEach(pipe => {
        ctx.save();
        ctx.translate(pipe.x + pipeWidth / 2, pipe.topHeight);
        ctx.scale(1, -1);
        ctx.drawImage(pipe.pipeImg, -pipeWidth/2, 0, pipeWidth, pipe.topHeight);
        ctx.restore();
        ctx.drawImage(pipe.pipeImg, pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
      });
    }
    function createPipe() {
      let gap = hardModeEnabled ? canvas.height * 0.25 : canvas.height * 0.3;
      const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;
      let pipeImg;
      if(selectedTheme === "JUNGLE"){
        pipeImg = (Math.random() < 0.6) ? pipeImageJungle1 : pipeImageJungle2;
      } else {
        pipeImg = pipeImage;
      }
      let design = (currentPipeDesign !== "0" && pipeDesigns[currentPipeDesign]) ? pipeDesigns[currentPipeDesign] : null;
      let color = design ? design.colors[0] : "#fff";
      pipes.push({
        x: canvas.width,
        topHeight: gapPosition,
        bottomY: gapPosition + gap,
        passed: false,
        color: color,
        design: design,
        pipeImg: pipeImg
      });
      if(selectedMode === "FLYING") {
        flyingPipeCounter++;
        if (flyingPipeCounter % 5 === 0) {
          createCoin(gapPosition, gap);
        }
      }
    }
    function checkCollision(pipe) {
      let topPipeLeft = pipe.x + collisionOffsetLeft;
      let topPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let topPipeBottom = pipe.topHeight - collisionOffsetTop;
      let bottomPipeLeft = pipe.x + collisionOffsetLeft;
      let bottomPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let bottomPipeTop = pipe.bottomY + collisionOffsetBottom;
      let playerLeft = shadow.x;
      let playerRight = shadow.x + shadow.width;
      let playerTop = shadow.y;
      let playerBottom = shadow.y + shadow.height;
      let collidesTop =
        playerRight > topPipeLeft &&
        playerLeft < topPipeRight &&
        playerTop < topPipeBottom;
      let collidesBottom =
        playerRight > bottomPipeLeft &&
        playerLeft < bottomPipeRight &&
        playerBottom > bottomPipeTop;
      return collidesTop || collidesBottom;
    }
    function createCoin(gapPosition, gapSize) {
      let coin = {
        x: canvas.width + pipeWidth / 2,
        y: gapPosition + gapSize / 2,
        radius: canvas.width * 0.03,
        collected: false
      };
      let coinEl = document.createElement('img');
      coinEl.src = 'BACKGROUND/goldcoin.gif';
      coinEl.style.position = 'absolute';
      coinEl.style.pointerEvents = 'none';
      coinEl.style.left = (coin.x - coin.radius) + "px";
      coinEl.style.top = (coin.y - coin.radius) + "px";
      coinEl.style.width = (coin.radius * 2) + "px";
      coinEl.style.height = (coin.radius * 2) + "px";
      document.getElementById('coinContainer').appendChild(coinEl);
      coin.el = coinEl;
      coins.push(coin);
    }
    function updateCoins() {
      coins.forEach((coin, index) => {
        if (!coin.collected) {
          coin.el.style.left = (coin.x - coin.radius) + "px";
          coin.el.style.top = (coin.y - coin.radius) + "px";
        } else {
          coin.el.remove();
          coins.splice(index, 1);
        }
      });
    }
    function removeAllCoins() {
      coins.forEach(coin => { if (coin.el) { coin.el.remove(); } });
      coins = [];
    }
    function checkCoinCollision(coin) {
      let cx = coin.x, cy = coin.y;
      let rx = shadow.x, ry = shadow.y;
      let rw = shadow.width, rh = shadow.height;
      let nearestX = Math.max(rx, Math.min(cx, rx + rw));
      let nearestY = Math.max(ry, Math.min(cy, ry + rh));
      let dx = cx - nearestX;
      let dy = cy - nearestY;
      return (dx * dx + dy * dy) < (coin.radius * coin.radius);
    }
    function spawnParticle(x, y) {
      particles.push({ x: x, y: y, size: Math.random() * 4 + 4, alpha: 1, decay: Math.random() * 0.03 + 0.01 });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function showReaction(message) {
      reactionMessages.push({ text: message, timer: 120, x: canvas.width / 2, y: canvas.height / 2 });
    }
    function drawReactions() {
      reactionMessages.forEach((msg, index) => {
        ctx.save();
        ctx.font = "20px 'Press Start 2P'";
        ctx.globalAlpha = msg.timer / 120;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.text, msg.x, msg.y);
        ctx.restore();
        msg.timer--;
        if (msg.timer <= 0) {
          reactionMessages.splice(index, 1);
        }
      });
    }
    function saveScore(name, points) {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      scores.push({ name, points });
      scores.sort((a, b) => b.points - a.points);
      scores = scores.slice(0, 5);
      localStorage.setItem("scores", JSON.stringify(scores));
      updateLeaderboard();
    }
    function updateLeaderboard() {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      topScoresList.innerHTML = scores.map(s => `<li>${s.name}: ${s.points}</li>`).join("");
    }
    updateLeaderboard();

    /* ================= Остальные режимы остаются без изменений ================= */
    let shadow = null;
    function startFlyingMode() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      coins = [];
      pipes = [];
      particles = [];
      reactionMessages = [];
      scoreElement.style.display = 'block';
      coinCountElement.style.display = 'flex';
      nerpaImg = shadow && (shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall);
      shadow = {
        x: canvas.width * 0.1,
        y: canvas.height * 0.5,
        width: canvas.width * 0.1,
        height: canvas.width * 0.1,
        velocity: 0,
        gravity: 0.35,
        jump: -6
      };
      canvas.addEventListener("mousedown", flyJump);
      canvas.addEventListener("touchstart", flyJumpTouch);
      flyingGameLoop();
    }
    function flyJump(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyJumpTouch(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyingGameLoop() {
      if (!gameStarted || paused) return;
      clearCanvas();
      shadow.velocity += shadow.gravity;
      shadow.y += shadow.velocity;
      spawnParticle(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      updateParticles();
      if(selectedTheme === "JUNGLE"){
        if(Math.random() < 0.02) {
          spawnLeaf();
        }
        updateLeafParticles();
        drawLeafParticles();
      }
      if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (canvas.width * 0.5)) {
        createPipe();
      }
      for (let pipe of pipes) {
        pipe.x -= pipeSpeed;
        if (!pipe.passed && pipe.x + pipeWidth < shadow.x) {
          score++;
          pipe.passed = true;
          if (score % 10 === 0) { showReaction('Score ' + score); }
        }
        if (checkCollision(pipe) || shadow.y < 0 || shadow.y + shadow.height > canvas.height) {
          clearCanvas();
          gameStarted = false;
          removeAllCoins();
          scoreElement.style.display = 'none';
          coinCountElement.style.display = 'none';
          addXP(score);
          setTimeout(() => {
            saveScore(usernameGame, score);
            gameOverOverlay.style.display = 'block';
          }, 1000);
          return;
        }
      }
      coins.forEach(coin => {
        coin.x -= pipeSpeed;
        if (!coin.collected && checkCoinCollision(coin)) {
          coin.collected = true;
          coinCount++;
          totalCoins++;
          localStorage.setItem("totalCoins", totalCoins);
          shopBalance.textContent = `Total Coins: ${totalCoins}`;
        }
      });
      updateCoins();
      drawParticles();
      updateShadowImage();
      ctx.save();
      ctx.translate(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      let angle = shadow.velocity < 0 ? -15 * Math.PI/180 : 15 * Math.PI/180;
      ctx.rotate(angle);
      let img = shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall;
      ctx.drawImage(img, -shadow.width/2, -shadow.height/2, shadow.width, shadow.height);
      ctx.restore();
      drawPipes();
      scoreElement.textContent = `Score: ${score}`;
      document.getElementById('coinText').textContent = coinCount;
      drawReactions();
      requestAnimationFrame(flyingGameLoop);
    }
    function drawPipes() {
      pipes.forEach(pipe => {
        ctx.save();
        ctx.translate(pipe.x + pipeWidth / 2, pipe.topHeight);
        ctx.scale(1, -1);
        ctx.drawImage(pipe.pipeImg, -pipeWidth/2, 0, pipeWidth, pipe.topHeight);
        ctx.restore();
        ctx.drawImage(pipe.pipeImg, pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
      });
    }
    function createPipe() {
      let gap = hardModeEnabled ? canvas.height * 0.25 : canvas.height * 0.3;
      const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;
      let pipeImg;
      if(selectedTheme === "JUNGLE"){
        pipeImg = (Math.random() < 0.6) ? pipeImageJungle1 : pipeImageJungle2;
      } else {
        pipeImg = pipeImage;
      }
      let design = (currentPipeDesign !== "0" && pipeDesigns[currentPipeDesign]) ? pipeDesigns[currentPipeDesign] : null;
      let color = design ? design.colors[0] : "#fff";
      pipes.push({
        x: canvas.width,
        topHeight: gapPosition,
        bottomY: gapPosition + gap,
        passed: false,
        color: color,
        design: design,
        pipeImg: pipeImg
      });
      if(selectedMode === "FLYING") {
        flyingPipeCounter++;
        if (flyingPipeCounter % 5 === 0) {
          createCoin(gapPosition, gap);
        }
      }
    }
    function checkCollision(pipe) {
      let topPipeLeft = pipe.x + collisionOffsetLeft;
      let topPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let topPipeBottom = pipe.topHeight - collisionOffsetTop;
      let bottomPipeLeft = pipe.x + collisionOffsetLeft;
      let bottomPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let bottomPipeTop = pipe.bottomY + collisionOffsetBottom;
      let playerLeft = shadow.x;
      let playerRight = shadow.x + shadow.width;
      let playerTop = shadow.y;
      let playerBottom = shadow.y + shadow.height;
      let collidesTop =
        playerRight > topPipeLeft &&
        playerLeft < topPipeRight &&
        playerTop < topPipeBottom;
      let collidesBottom =
        playerRight > bottomPipeLeft &&
        playerLeft < bottomPipeRight &&
        playerBottom > bottomPipeTop;
      return collidesTop || collidesBottom;
    }
    function createCoin(gapPosition, gapSize) {
      let coin = {
        x: canvas.width + pipeWidth / 2,
        y: gapPosition + gapSize / 2,
        radius: canvas.width * 0.03,
        collected: false
      };
      let coinEl = document.createElement('img');
      coinEl.src = 'BACKGROUND/goldcoin.gif';
      coinEl.style.position = 'absolute';
      coinEl.style.pointerEvents = 'none';
      coinEl.style.left = (coin.x - coin.radius) + "px";
      coinEl.style.top = (coin.y - coin.radius) + "px";
      coinEl.style.width = (coin.radius * 2) + "px";
      coinEl.style.height = (coin.radius * 2) + "px";
      document.getElementById('coinContainer').appendChild(coinEl);
      coin.el = coinEl;
      coins.push(coin);
    }
    function updateCoins() {
      coins.forEach((coin, index) => {
        if (!coin.collected) {
          coin.el.style.left = (coin.x - coin.radius) + "px";
          coin.el.style.top = (coin.y - coin.radius) + "px";
        } else {
          coin.el.remove();
          coins.splice(index, 1);
        }
      });
    }
    function removeAllCoins() {
      coins.forEach(coin => { if (coin.el) { coin.el.remove(); } });
      coins = [];
    }
    function checkCoinCollision(coin) {
      let cx = coin.x, cy = coin.y;
      let rx = shadow.x, ry = shadow.y;
      let rw = shadow.width, rh = shadow.height;
      let nearestX = Math.max(rx, Math.min(cx, rx + rw));
      let nearestY = Math.max(ry, Math.min(cy, ry + rh));
      let dx = cx - nearestX;
      let dy = cy - nearestY;
      return (dx * dx + dy * dy) < (coin.radius * coin.radius);
    }
    function spawnParticle(x, y) {
      particles.push({ x: x, y: y, size: Math.random() * 4 + 4, alpha: 1, decay: Math.random() * 0.03 + 0.01 });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function showReaction(message) {
      reactionMessages.push({ text: message, timer: 120, x: canvas.width / 2, y: canvas.height / 2 });
    }
    function drawReactions() {
      reactionMessages.forEach((msg, index) => {
        ctx.save();
        ctx.font = "20px 'Press Start 2P'";
        ctx.globalAlpha = msg.timer / 120;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.text, msg.x, msg.y);
        ctx.restore();
        msg.timer--;
        if (msg.timer <= 0) {
          reactionMessages.splice(index, 1);
        }
      });
    }
    function saveScore(name, points) {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      scores.push({ name, points });
      scores.sort((a, b) => b.points - a.points);
      scores = scores.slice(0, 5);
      localStorage.setItem("scores", JSON.stringify(scores));
      updateLeaderboard();
    }
    function updateLeaderboard() {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      topScoresList.innerHTML = scores.map(s => `<li>${s.name}: ${s.points}</li>`).join("");
    }
    updateLeaderboard();

    /* ================= Остальные режимы остаются без изменений ================= */
    let shadow = null;
    function startFlyingMode() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      coins = [];
      pipes = [];
      particles = [];
      reactionMessages = [];
      scoreElement.style.display = 'block';
      coinCountElement.style.display = 'flex';
      nerpaImg = shadow && (shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall);
      shadow = {
        x: canvas.width * 0.1,
        y: canvas.height * 0.5,
        width: canvas.width * 0.1,
        height: canvas.width * 0.1,
        velocity: 0,
        gravity: 0.35,
        jump: -6
      };
      canvas.addEventListener("mousedown", flyJump);
      canvas.addEventListener("touchstart", flyJumpTouch);
      flyingGameLoop();
    }
    function flyJump(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyJumpTouch(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyingGameLoop() {
      if (!gameStarted || paused) return;
      clearCanvas();
      shadow.velocity += shadow.gravity;
      shadow.y += shadow.velocity;
      spawnParticle(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      updateParticles();
      if(selectedTheme === "JUNGLE"){
        if(Math.random() < 0.02) {
          spawnLeaf();
        }
        updateLeafParticles();
        drawLeafParticles();
      }
      if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (canvas.width * 0.5)) {
        createPipe();
      }
      for (let pipe of pipes) {
        pipe.x -= pipeSpeed;
        if (!pipe.passed && pipe.x + pipeWidth < shadow.x) {
          score++;
          pipe.passed = true;
          if (score % 10 === 0) { showReaction('Score ' + score); }
        }
        if (checkCollision(pipe) || shadow.y < 0 || shadow.y + shadow.height > canvas.height) {
          clearCanvas();
          gameStarted = false;
          removeAllCoins();
          scoreElement.style.display = 'none';
          coinCountElement.style.display = 'none';
          addXP(score);
          setTimeout(() => {
            saveScore(usernameGame, score);
            gameOverOverlay.style.display = 'block';
          }, 1000);
          return;
        }
      }
      coins.forEach(coin => {
        coin.x -= pipeSpeed;
        if (!coin.collected && checkCoinCollision(coin)) {
          coin.collected = true;
          coinCount++;
          totalCoins++;
          localStorage.setItem("totalCoins", totalCoins);
          shopBalance.textContent = `Total Coins: ${totalCoins}`;
        }
      });
      updateCoins();
      drawParticles();
      updateShadowImage();
      ctx.save();
      ctx.translate(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      let angle = shadow.velocity < 0 ? -15 * Math.PI/180 : 15 * Math.PI/180;
      ctx.rotate(angle);
      let img = shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall;
      ctx.drawImage(img, -shadow.width/2, -shadow.height/2, shadow.width, shadow.height);
      ctx.restore();
      drawPipes();
      scoreElement.textContent = `Score: ${score}`;
      document.getElementById('coinText').textContent = coinCount;
      drawReactions();
      requestAnimationFrame(flyingGameLoop);
    }
    function drawPipes() {
      pipes.forEach(pipe => {
        ctx.save();
        ctx.translate(pipe.x + pipeWidth / 2, pipe.topHeight);
        ctx.scale(1, -1);
        ctx.drawImage(pipe.pipeImg, -pipeWidth/2, 0, pipeWidth, pipe.topHeight);
        ctx.restore();
        ctx.drawImage(pipe.pipeImg, pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
      });
    }
    function createPipe() {
      let gap = hardModeEnabled ? canvas.height * 0.25 : canvas.height * 0.3;
      const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;
      let pipeImg;
      if(selectedTheme === "JUNGLE"){
        pipeImg = (Math.random() < 0.6) ? pipeImageJungle1 : pipeImageJungle2;
      } else {
        pipeImg = pipeImage;
      }
      let design = (currentPipeDesign !== "0" && pipeDesigns[currentPipeDesign]) ? pipeDesigns[currentPipeDesign] : null;
      let color = design ? design.colors[0] : "#fff";
      pipes.push({
        x: canvas.width,
        topHeight: gapPosition,
        bottomY: gapPosition + gap,
        passed: false,
        color: color,
        design: design,
        pipeImg: pipeImg
      });
      if(selectedMode === "FLYING") {
        flyingPipeCounter++;
        if (flyingPipeCounter % 5 === 0) {
          createCoin(gapPosition, gap);
        }
      }
    }
    function checkCollision(pipe) {
      let topPipeLeft = pipe.x + collisionOffsetLeft;
      let topPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let topPipeBottom = pipe.topHeight - collisionOffsetTop;
      let bottomPipeLeft = pipe.x + collisionOffsetLeft;
      let bottomPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let bottomPipeTop = pipe.bottomY + collisionOffsetBottom;
      let playerLeft = shadow.x;
      let playerRight = shadow.x + shadow.width;
      let playerTop = shadow.y;
      let playerBottom = shadow.y + shadow.height;
      let collidesTop =
        playerRight > topPipeLeft &&
        playerLeft < topPipeRight &&
        playerTop < topPipeBottom;
      let collidesBottom =
        playerRight > bottomPipeLeft &&
        playerLeft < bottomPipeRight &&
        playerBottom > bottomPipeTop;
      return collidesTop || collidesBottom;
    }
    function createCoin(gapPosition, gapSize) {
      let coin = {
        x: canvas.width + pipeWidth / 2,
        y: gapPosition + gapSize / 2,
        radius: canvas.width * 0.03,
        collected: false
      };
      let coinEl = document.createElement('img');
      coinEl.src = 'BACKGROUND/goldcoin.gif';
      coinEl.style.position = 'absolute';
      coinEl.style.pointerEvents = 'none';
      coinEl.style.left = (coin.x - coin.radius) + "px";
      coinEl.style.top = (coin.y - coin.radius) + "px";
      coinEl.style.width = (coin.radius * 2) + "px";
      coinEl.style.height = (coin.radius * 2) + "px";
      document.getElementById('coinContainer').appendChild(coinEl);
      coin.el = coinEl;
      coins.push(coin);
    }
    function updateCoins() {
      coins.forEach((coin, index) => {
        if (!coin.collected) {
          coin.el.style.left = (coin.x - coin.radius) + "px";
          coin.el.style.top = (coin.y - coin.radius) + "px";
        } else {
          coin.el.remove();
          coins.splice(index, 1);
        }
      });
    }
    function removeAllCoins() {
      coins.forEach(coin => { if (coin.el) { coin.el.remove(); } });
      coins = [];
    }
    function checkCoinCollision(coin) {
      let cx = coin.x, cy = coin.y;
      let rx = shadow.x, ry = shadow.y;
      let rw = shadow.width, rh = shadow.height;
      let nearestX = Math.max(rx, Math.min(cx, rx + rw));
      let nearestY = Math.max(ry, Math.min(cy, ry + rh));
      let dx = cx - nearestX;
      let dy = cy - nearestY;
      return (dx * dx + dy * dy) < (coin.radius * coin.radius);
    }
    function spawnParticle(x, y) {
      particles.push({ x: x, y: y, size: Math.random() * 4 + 4, alpha: 1, decay: Math.random() * 0.03 + 0.01 });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function showReaction(message) {
      reactionMessages.push({ text: message, timer: 120, x: canvas.width / 2, y: canvas.height / 2 });
    }
    function drawReactions() {
      reactionMessages.forEach((msg, index) => {
        ctx.save();
        ctx.font = "20px 'Press Start 2P'";
        ctx.globalAlpha = msg.timer / 120;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.text, msg.x, msg.y);
        ctx.restore();
        msg.timer--;
        if (msg.timer <= 0) {
          reactionMessages.splice(index, 1);
        }
      });
    }
    function saveScore(name, points) {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      scores.push({ name, points });
      scores.sort((a, b) => b.points - a.points);
      scores = scores.slice(0, 5);
      localStorage.setItem("scores", JSON.stringify(scores));
      updateLeaderboard();
    }
    function updateLeaderboard() {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      topScoresList.innerHTML = scores.map(s => `<li>${s.name}: ${s.points}</li>`).join("");
    }
    updateLeaderboard();

    /* ================= Остальные режимы остаются без изменений ================= */
    let shadow = null;
    function startFlyingMode() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      coins = [];
      pipes = [];
      particles = [];
      reactionMessages = [];
      scoreElement.style.display = 'block';
      coinCountElement.style.display = 'flex';
      nerpaImg = shadow && (shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall);
      shadow = {
        x: canvas.width * 0.1,
        y: canvas.height * 0.5,
        width: canvas.width * 0.1,
        height: canvas.width * 0.1,
        velocity: 0,
        gravity: 0.35,
        jump: -6
      };
      canvas.addEventListener("mousedown", flyJump);
      canvas.addEventListener("touchstart", flyJumpTouch);
      flyingGameLoop();
    }
    function flyJump(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyJumpTouch(e) {
      e.preventDefault();
      shadow.velocity = shadow.jump;
    }
    function flyingGameLoop() {
      if (!gameStarted || paused) return;
      clearCanvas();
      shadow.velocity += shadow.gravity;
      shadow.y += shadow.velocity;
      spawnParticle(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      updateParticles();
      if(selectedTheme === "JUNGLE"){
        if(Math.random() < 0.02) {
          spawnLeaf();
        }
        updateLeafParticles();
        drawLeafParticles();
      }
      if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (canvas.width * 0.5)) {
        createPipe();
      }
      for (let pipe of pipes) {
        pipe.x -= pipeSpeed;
        if (!pipe.passed && pipe.x + pipeWidth < shadow.x) {
          score++;
          pipe.passed = true;
          if (score % 10 === 0) { showReaction('Score ' + score); }
        }
        if (checkCollision(pipe) || shadow.y < 0 || shadow.y + shadow.height > canvas.height) {
          clearCanvas();
          gameStarted = false;
          removeAllCoins();
          scoreElement.style.display = 'none';
          coinCountElement.style.display = 'none';
          addXP(score);
          setTimeout(() => {
            saveScore(usernameGame, score);
            gameOverOverlay.style.display = 'block';
          }, 1000);
          return;
        }
      }
      coins.forEach(coin => {
        coin.x -= pipeSpeed;
        if (!coin.collected && checkCoinCollision(coin)) {
          coin.collected = true;
          coinCount++;
          totalCoins++;
          localStorage.setItem("totalCoins", totalCoins);
          shopBalance.textContent = `Total Coins: ${totalCoins}`;
        }
      });
      updateCoins();
      drawParticles();
      updateShadowImage();
      ctx.save();
      ctx.translate(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      let angle = shadow.velocity < 0 ? -15 * Math.PI/180 : 15 * Math.PI/180;
      ctx.rotate(angle);
      let img = shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall;
      ctx.drawImage(img, -shadow.width/2, -shadow.height/2, shadow.width, shadow.height);
      ctx.restore();
      drawPipes();
      scoreElement.textContent = `Score: ${score}`;
      document.getElementById('coinText').textContent = coinCount;
      drawReactions();
      requestAnimationFrame(flyingGameLoop);
    }
    function drawPipes() {
      pipes.forEach(pipe => {
        ctx.save();
        ctx.translate(pipe.x + pipeWidth / 2, pipe.topHeight);
        ctx.scale(1, -1);
        ctx.drawImage(pipe.pipeImg, -pipeWidth/2, 0, pipeWidth, pipe.topHeight);
        ctx.restore();
        ctx.drawImage(pipe.pipeImg, pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
      });
    }
    function createPipe() {
      let gap = hardModeEnabled ? canvas.height * 0.25 : canvas.height * 0.3;
      const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;
      let pipeImg;
      if(selectedTheme === "JUNGLE"){
        pipeImg = (Math.random() < 0.6) ? pipeImageJungle1 : pipeImageJungle2;
      } else {
        pipeImg = pipeImage;
      }
      let design = (currentPipeDesign !== "0" && pipeDesigns[currentPipeDesign]) ? pipeDesigns[currentPipeDesign] : null;
      let color = design ? design.colors[0] : "#fff";
      pipes.push({
        x: canvas.width,
        topHeight: gapPosition,
        bottomY: gapPosition + gap,
        passed: false,
        color: color,
        design: design,
        pipeImg: pipeImg
      });
      if(selectedMode === "FLYING") {
        flyingPipeCounter++;
        if (flyingPipeCounter % 5 === 0) {
          createCoin(gapPosition, gap);
        }
      }
    }
    function checkCollision(pipe) {
      let topPipeLeft = pipe.x + collisionOffsetLeft;
      let topPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let topPipeBottom = pipe.topHeight - collisionOffsetTop;
      let bottomPipeLeft = pipe.x + collisionOffsetLeft;
      let bottomPipeRight = pipe.x + pipeWidth - collisionOffsetRight;
      let bottomPipeTop = pipe.bottomY + collisionOffsetBottom;
      let playerLeft = shadow.x;
      let playerRight = shadow.x + shadow.width;
      let playerTop = shadow.y;
      let playerBottom = shadow.y + shadow.height;
      let collidesTop =
        playerRight > topPipeLeft &&
        playerLeft < topPipeRight &&
        playerTop < topPipeBottom;
      let collidesBottom =
        playerRight > bottomPipeLeft &&
        playerLeft < bottomPipeRight &&
        playerBottom > bottomPipeTop;
      return collidesTop || collidesBottom;
    }
    function createCoin(gapPosition, gapSize) {
      let coin = {
        x: canvas.width + pipeWidth / 2,
        y: gapPosition + gapSize / 2,
        radius: canvas.width * 0.03,
        collected: false
      };
      let coinEl = document.createElement('img');
      coinEl.src = 'BACKGROUND/goldcoin.gif';
      coinEl.style.position = 'absolute';
      coinEl.style.pointerEvents = 'none';
      coinEl.style.left = (coin.x - coin.radius) + "px";
      coinEl.style.top = (coin.y - coin.radius) + "px";
      coinEl.style.width = (coin.radius * 2) + "px";
      coinEl.style.height = (coin.radius * 2) + "px";
      document.getElementById('coinContainer').appendChild(coinEl);
      coin.el = coinEl;
      coins.push(coin);
    }
    function updateCoins() {
      coins.forEach((coin, index) => {
        if (!coin.collected) {
          coin.el.style.left = (coin.x - coin.radius) + "px";
          coin.el.style.top = (coin.y - coin.radius) + "px";
        } else {
          coin.el.remove();
          coins.splice(index, 1);
        }
      });
    }
    function removeAllCoins() {
      coins.forEach(coin => { if (coin.el) { coin.el.remove(); } });
      coins = [];
    }
    function checkCoinCollision(coin) {
      let cx = coin.x, cy = coin.y;
      let rx = shadow.x, ry = shadow.y;
      let rw = shadow.width, rh = shadow.height;
      let nearestX = Math.max(rx, Math.min(cx, rx + rw));
      let nearestY = Math.max(ry, Math.min(cy, ry + rh));
      let dx = cx - nearestX;
      let dy = cy - nearestY;
      return (dx * dx + dy * dy) < (coin.radius * coin.radius);
    }
    function spawnParticle(x, y) {
      particles.push({ x: x, y: y, size: Math.random() * 4 + 4, alpha: 1, decay: Math.random() * 0.03 + 0.01 });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function showReaction(message) {
      reactionMessages.push({ text: message, timer: 120, x: canvas.width / 2, y: canvas.height / 2 });
    }
    function drawReactions() {
      reactionMessages.forEach((msg, index) => {
        ctx.save();
        ctx.font = "20px 'Press Start 2P'";
        ctx.globalAlpha = msg.timer / 120;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.text, msg.x, msg.y);
        ctx.restore();
        msg.timer--;
        if (msg.timer <= 0) {
          reactionMessages.splice(index, 1);
        }
      });
    }
    function saveScore(name, points) {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      scores.push({ name, points });
      scores.sort((a, b) => b.points - a.points);
      scores = scores.slice(0, 5);
      localStorage.setItem("scores", JSON.stringify(scores));
      updateLeaderboard();
    }
    function updateLeaderboard() {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      topScoresList.innerHTML = scores.map(s => `<li>${s.name}: ${s.points}</li>`).join("");
    }
    updateLeaderboard();

    /* ================= События главного меню ================= */
    startBtn.addEventListener('click', () => {
      themeSelectModal.style.display = 'flex';
    });
    document.getElementById("winterThemeBtn").addEventListener("click", () => {
      selectedTheme = "WINTER";
      updateTheme();
      themeSelectModal.style.display = "none";
      modeSelectModal.style.display = "flex";
    });
    document.getElementById("jungleThemeBtn").addEventListener("click", () => {
      selectedTheme = "JUNGLE";
      updateTheme();
      themeSelectModal.style.display = "none";
      modeSelectModal.style.display = "flex";
    });
    flyingModeBtn.addEventListener('click', () => {
      modeSelectModal.style.display = 'none';
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      platformerPauseBtn.style.display = 'none';
      coinCountElement.style.display = 'flex';
      hideProfileButton();
      platformerControls.style.display = 'none';
      selectedMode = "FLYING";
      flyingPipeCounter++;
      startFlyingMode();
    });
    platformerModeBtn.addEventListener('click', () => {
      modeSelectModal.style.display = 'none';
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      platformerPauseBtn.style.display = 'block';
      coinCountElement.style.display = 'none';
      hideProfileButton();
      platformerControls.style.display = 'flex';
      selectedMode = "PLATFORMER";
      startPlatformerLevel();
    });
    dunkModeBtn.addEventListener('click', () => {
      modeSelectModal.style.display = 'none';
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      hideProfileButton();
      selectedMode = "DUNK";
      startDunkMode();
    });
    telegramBtn.addEventListener('click', () => {
      window.open('https://t.me/FlyingSealCoin', '_blank');
    });
    shopBtn.addEventListener('click', () => {
      menu.style.display = 'none';
      shop.style.display = 'flex';
      renderShopItems();
    });
    shopBackBtn.addEventListener('click', () => {
      shop.style.display = 'none';
      menu.style.display = 'flex';
      platformerControls.style.display = 'none';
    });
    shareBtn.addEventListener('click', () => {
      const shareText = `Beat my record in FLYING SEAL! My record is ${score}`;
      const shareUrl = "https://t.me/FlyingSealBot/FLYING";
      const telegramShareLink = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(shareText)}`;
      window.open(telegramShareLink, '_blank');
    });
    continueBtn.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      if(selectedMode === "FLYING") { startFlyingMode(); }
      else if(selectedMode === "PLATFORMER") { startPlatformerLevel(); }
      else if(selectedMode === "DUNK") { startDunkMode(); }
    });
    mainMenuBtn.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      menu.style.display = 'flex';
      showProfileButton();
      platformerPauseBtn.style.display = 'none';
      platformerControls.style.display = 'none';
      gameStarted = false;
      platformerGameStarted = false;
      dunkModeActive = false;
      dunkModeActive = false;
      paused = false;
      clearCanvas();
      currentPlatforms = [];
      pipes = [];
      coins = [];
      score = 0;
      coinCount = 0;
      addXP(score);
    });
    closeHardModeDesc.addEventListener('click', () => {
      hardModeDescription.style.display = 'none';
    });
    platformerPauseBtn.addEventListener('click', () => {
      paused = true;
      pauseMenu.style.display = 'block';
    });
    const resumeBtn = document.getElementById('resumeBtn');
    resumeBtn.addEventListener('click', () => {
      paused = false;
      pauseMenu.style.display = 'none';
      if (selectedMode === "FLYING") { flyingGameLoop(); }
      else if (selectedMode === "PLATFORMER") { platformerLoop(currentPlatforms); }
      else if(selectedMode === "DUNK") { dunkModeLoop(); }
    });
    const exitBtn = document.getElementById('exitBtn');
    exitBtn.addEventListener('click', () => {
      paused = false;
      pauseMenu.style.display = 'none';
      menu.style.display = 'flex';
      showProfileButton();
      platformerPauseBtn.style.display = 'none';
      platformerControls.style.display = 'none';
      gameStarted = false;
      platformerGameStarted = false;
      dunkModeActive = false;
      clearCanvas();
      currentPlatforms = [];
      pipes = [];
      coins = [];
      score = 0;
      coinCount = 0;
    });
    function hideProfileButton() { document.getElementById('profileBtn').style.display = 'none'; }
    function showProfileButton() { document.getElementById('profileBtn').style.display = 'block'; }
    function updateShadowImage() {
      nerpaImg = shadow.velocity < 0 ? currentCharacterJump : currentCharacterFall;
    }
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  </script>
</body>
</html>

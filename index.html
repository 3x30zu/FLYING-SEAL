<!DOCTYPE html>
<html>
<head>
  <title>Shadow Flappy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!-- Пиксельный шрифт -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Press Start 2P', cursive;
      background: #000;
    }
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      border: none;
    }
    /* Главное меню */
    #menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    #menu img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: -1;
    }
    /* Отображение общего количества монет в меню */
    #menu p {
      font-size: 3vw;
      margin: 10px 0;
    }
    /* leaderboard с дизайном кнопок и отступом */
    #leaderboard {
      margin-top: 40px;
      text-align: center;
      font-size: 12px;
      background: #3498db;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      padding: 10px;
      border-radius: 0;
      image-rendering: pixelated;
    }
    /* Магазин */
    #shop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Фон магазина: наложение черного градиента и фон из главного меню */
      background: linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.8)), 
                  url('https://ltdfoto.ru/images/2025/03/18/photo_2025-03-12_12-26-18.jpg') center/cover no-repeat;
      color: white;
      display: none;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
      padding: 20px;
      z-index: 30;
    }
    #shop h2 {
      font-size: 5vw;
      margin-bottom: 20px;
    }
    .shop-item {
      background: #3498db;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      padding: 10px;
      margin: 20px 0;
      width: 80%;
      text-align: center;
      image-rendering: pixelated;
    }
    .shop-item button {
      margin-top: 10px;
    }
    #shop .back-btn {
      margin-top: 20px;
      background: #FF5722;
      border-color: #fff;
      box-shadow: 4px 4px 0 #00ffff;
    }
    /* Оверлей для Game Over */
    #gameOverOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      text-align: center;
      padding: 20px;
    }
    /* Контейнер для награды за Hard Mode */
    #hardModeRewardContainer {
      margin-top: 20px;
      display: none;
    }
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-20px); }
      60% { transform: translateY(-10px); }
    }
    /* Анимация для плавающих кнопок */
    @keyframes float {
      0%   { transform: translateX(0); }
      50%  { transform: translateX(5px); }
      100% { transform: translateX(0); }
    }
    #menu h1, #gameOverOverlay h2 {
      font-size: 5vw;
      margin-bottom: 20px;
      animation: bounce 2s infinite;
    }
    #menu input {
      font-size: 3vw;
      padding: 10px;
      text-align: center;
      margin-bottom: 15px;
      font-family: 'Press Start 2P', cursive;
      letter-spacing: 2px;
    }
    button {
      padding: 10px 20px;
      font-size: 3vw;
      font-family: 'Press Start 2P', cursive;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #fff;
      background: #3498db;
      border: 4px solid #fff;
      border-radius: 0;
      box-shadow: 4px 4px 0 #00ffff;
      image-rendering: pixelated;
      cursor: pointer;
      margin-bottom: 15px;
      transition: all 0.1s;
      animation: float 3s ease-in-out infinite;
    }
    button:active {
      box-shadow: 2px 2px 0 #00ffff;
      transform: translate(2px, 2px);
    }
    #score, #coinCount {
      position: absolute;
      color: white;
      font-size: 4vw;
      z-index: 5;
    }
    #score {
      top: 5%;
      left: 5%;
    }
    #coinCount {
      top: 5%;
      right: 5%;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- Главное меню -->
  <div id="menu">
    <img src="https://ltdfoto.ru/images/2025/03/18/photo_2025-03-12_12-26-18.jpg" alt="Menu Background">
    <h1>FLYING SEAL</h1>
    <p id="menuTotalCoins">Total Coins: 0</p>
    <input type="text" id="nickname" placeholder="Введите никнейм">
    <button id="startBtn">GO!</button>
    <button id="telegramBtn">TELEGRAM</button>
    <button id="shopBtn">SHOP</button>
    <!-- Блок топ результатов в главном меню -->
    <div id="leaderboard">
      <h3>Топ результатов</h3>
      <ul id="topScores"></ul>
    </div>
  </div>
  <!-- Магазин трейлов -->
  <div id="shop">
    <h2>Shop</h2>
    <div id="shopItems"></div>
    <button class="back-btn" id="shopBackBtn">Back</button>
  </div>
  <!-- Оверлей для Game Over -->
  <div id="gameOverOverlay">
    <h2>Share the result with your friends!</h2>
    <button id="shareBtn">Share the result!</button>
    <button id="continueBtn">Continue game!</button>
    <button id="mainMenuBtn">MAIN MENU</button>
    <!-- Контейнер для награды за Hard Mode -->
    <div id="hardModeRewardContainer">
      <p id="hardModeCountText"></p>
      <button id="rewardBtn">GET REWARD</button>
    </div>
  </div>
  <div id="score"></div>
  <div id="coinCount">Coins: 0</div>
  <script>
    if (window.Telegram && window.Telegram.WebApp) {
      window.Telegram.WebApp.ready();
    }
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const shop = document.getElementById('shop');
    const shopItemsDiv = document.getElementById('shopItems');
    const shopBackBtn = document.getElementById('shopBackBtn');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const telegramBtn = document.getElementById('telegramBtn');
    const shopBtn = document.getElementById('shopBtn');
    const shareBtn = document.getElementById('shareBtn');
    const continueBtn = document.getElementById('continueBtn');
    const mainMenuBtn = document.getElementById('mainMenuBtn');
    const nicknameInput = document.getElementById('nickname');
    const scoreElement = document.getElementById('score');
    const coinCountElement = document.getElementById('coinCount');
    const menuTotalCoinsElement = document.getElementById('menuTotalCoins');
    const topScoresList = document.getElementById('topScores');
    const hardModeRewardContainer = document.getElementById('hardModeRewardContainer');
    const hardModeCountText = document.getElementById('hardModeCountText');
    const rewardBtn = document.getElementById('rewardBtn');

    let gameStarted = false;
    let score = 0;
    let coinCount = 0; // монеты, собранные в текущей игре
    let totalCoins = parseInt(localStorage.getItem("totalCoins") || "0");
    let username = "";

    // Храним список купленных трейлов и выбранный трейл
    let purchasedTrails = JSON.parse(localStorage.getItem("purchasedTrails") || '["1"]');
    let currentTrailId = localStorage.getItem("selectedTrail") || "1";

    menuTotalCoinsElement.textContent = `Total Coins: ${totalCoins}`;

    let waterDrips = [];
    let particles = [];
    let coins = [];

    // Эффекты (glow, реакции)
    let glowEffect = {
      active: false,
      color: '',
      intensity: 0
    };
    let reactionMessages = [];

    // --- Настройка эвентов Hard Mode ---
    // Состояния: "waiting", "countdown", "active", "chill"
    let hardEventState = "waiting";
    let nextHardEventTimer = getRandomEventTimer();
    let countdownTimer = 0; // обратный отсчёт (3,2,1)
    let hardModeCountdown = 0; // длительность Hard Mode (7 сек = 420 кадров)
    let chillTimer = 0; // время для сообщения CHILL (например, 60 кадров)
    let hardModeCount = 0; // количество успешно пройденных Hard Mode

    function getRandomEventTimer() {
      // 3-4 раза в минуту => 900-1200 кадров
      return Math.floor(Math.random() * (1200 - 900 + 1)) + 900;
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const originalShadowSrc = 'https://ltdfoto.ru/images/2025/03/17/photo_2025-03-12_11-06-57-removebg-preview8aaf5888645e399d.png';
    const fallingShadowSrc = 'https://ltdfoto.ru/images/2025/03/18/photo_2025-03-12_11-06-40-removebg-previewf904bc1020206391.png';
    const shadowImg = new Image();
    shadowImg.src = originalShadowSrc;

    const backgroundImg = new Image();
    backgroundImg.src = 'https://ltdfoto.ru/images/2025/03/18/photo_2025-03-12_12-26-18.jpg';

    const shadow = {
      x: canvas.width * 0.1,
      y: canvas.height * 0.5,
      width: canvas.width * 0.1,
      height: canvas.width * 0.1,
      velocity: 0,
      gravity: 0.35,
      jump: -6
    };

    let pipes = [];
    const pipeWidth = canvas.width * 0.1;
    const pipeSpeed = 2.5;
    const pipeColors = ["#00ccff", "#00aaff", "#0099ff", "#33ccff", "#66d9ff"];

    function generateEdgePoints(width, numPoints) {
      let points = [];
      for (let i = 0; i <= numPoints; i++) {
        let offset = (Math.random() * (width / 8)) - (width / 16);
        points.push(offset);
      }
      return points;
    }

    function drawIceBlock(x, y, width, height, isTop, edgePoints, color) {
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = 10;
      ctx.fillStyle = color;
      ctx.beginPath();
      if (isTop) {
        ctx.moveTo(x, y);
        ctx.lineTo(x + width, y);
        let numPoints = edgePoints.length - 1;
        for (let i = 0; i <= numPoints; i++) {
          let px = x + width - (width / numPoints) * i;
          let py = y + height + edgePoints[i];
          ctx.lineTo(px, py);
        }
        ctx.closePath();
      } else {
        ctx.moveTo(x, y + height);
        ctx.lineTo(x + width, y + height);
        let numPoints = edgePoints.length - 1;
        for (let i = 0; i <= numPoints; i++) {
          let px = x + width - (width / numPoints) * i;
          let py = y + edgePoints[i];
          ctx.lineTo(px, py);
        }
        ctx.closePath();
      }
      ctx.fill();
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function drawPipes() {
      pipes.forEach(pipe => {
        drawIceBlock(pipe.x, 0, pipeWidth, pipe.topHeight, true, pipe.topEdge, pipe.color);
        drawIceBlock(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY, false, pipe.bottomEdge, pipe.color);
      });
    }

    function updateWaterDrips() {
      let gravityDrip = 0.3;
      waterDrips.forEach((drip, index) => {
        drip.vy += gravityDrip;
        drip.y += drip.vy;
        if (drip.y > canvas.height || drip.y < 0) {
          waterDrips.splice(index, 1);
        }
      });
    }
    function drawWaterDrips() {
      ctx.fillStyle = "#00aaff";
      waterDrips.forEach(drip => {
        ctx.beginPath();
        ctx.arc(drip.x, drip.y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Настройки трейлов магазина
    const trailsConfig = {
      "1": {
        id: "1",
        name: "Default",
        price: 0,
        gradient: ["rgba(0,255,255,1)", "rgba(0,255,255,0)"],
        random: false
      },
      "2": {
        id: "2",
        name: "Blue Glow",
        price: 50,
        gradient: ["rgba(0,150,255,1)", "rgba(0,150,255,0)"],
        random: false
      },
      "3": {
        id: "3",
        name: "Rainbow",
        price: 100,
        gradient: ["rainbow", "rainbow"],
        random: true
      },
      "4": {
        id: "4",
        name: "Fire",
        price: 75,
        gradient: ["rgba(255,69,0,1)", "rgba(255,69,0,0)"],
        random: false
      },
      "5": {
        id: "5",
        name: "Electric",
        price: 150,
        gradient: ["rgba(255,255,0,1)", "rgba(255,255,0,0)"],
        random: false
      }
    };

    // Частицы трейла
    function drawParticles() {
      let currentTrail = trailsConfig[currentTrailId];
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        let gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        if (currentTrail.random) {
          const rainbowColors = ["rgba(255,0,0,1)", "rgba(255,127,0,1)", "rgba(255,255,0,1)", "rgba(0,255,0,1)", "rgba(0,0,255,1)", "rgba(75,0,130,1)", "rgba(148,0,211,1)"];
          let randColor = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
          gradient.addColorStop(0, randColor);
          gradient.addColorStop(1, randColor.replace("1)", "0)"));
        } else {
          gradient.addColorStop(0, currentTrail.gradient[0]);
          gradient.addColorStop(1, currentTrail.gradient[1]);
        }
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    
    function spawnParticle(x, y) {
      particles.push({
        x: x,
        y: y,
        size: Math.random() * 4 + 4,
        alpha: 1,
        decay: Math.random() * 0.03 + 0.01
      });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    // Создание монетки
    function createCoin(gapPosition) {
      let coin = {
        x: canvas.width + pipeWidth / 2,
        y: gapPosition + effectiveGap() / 2,
        radius: canvas.width * 0.02,
        collected: false
      };
      coins.push(coin);
    }

    // Монетка
    function drawPixelCoin(coin) {
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      let radius = coin.radius;
      ctx.fillStyle = "#FFC107";
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#FF9800";
      let innerRadius = radius * 0.4;
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, innerRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#B8860B";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    function drawCoins() {
      coins.forEach(coin => {
        if (!coin.collected) {
          drawPixelCoin(coin);
        }
      });
    }

    function checkCoinCollision(coin) {
      let cx = coin.x;
      let cy = coin.y;
      let rx = shadow.x;
      let ry = shadow.y;
      let rw = shadow.width;
      let rh = shadow.height;
      let nearestX = Math.max(rx, Math.min(cx, rx + rw));
      let nearestY = Math.max(ry, Math.min(cy, ry + rh));
      let dx = cx - nearestX;
      let dy = cy - nearestY;
      return (dx * dx + dy * dy) < (coin.radius * coin.radius);
    }

    // Функции эффектов
    function activateGlow(color, intensity) {
      glowEffect.active = true;
      glowEffect.color = color;
      glowEffect.intensity = intensity;
    }
    function showReaction(message) {
      reactionMessages.push({
        text: message,
        timer: 120,
        x: canvas.width / 2,
        y: canvas.height / 2
      });
    }
    function drawReactions() {
      reactionMessages.forEach((msg, index) => {
        ctx.save();
        ctx.font = "20px 'Press Start 2P'";
        ctx.globalAlpha = msg.timer / 120;
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(msg.text, msg.x, msg.y);
        ctx.restore();
        msg.timer--;
        if (msg.timer <= 0) {
          reactionMessages.splice(index, 1);
        }
      });
    }

    // Оверлей для Hard Mode эвента
    function drawHardModeOverlay() {
      ctx.save();
      ctx.textAlign = "center";
      if (hardEventState === "countdown") {
        let secondsLeft = Math.ceil(countdownTimer / 60);
        // Меньший размер надписи для мобильных устройств
        ctx.font = "40px 'Press Start 2P'";
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillText(secondsLeft, canvas.width / 2, canvas.height / 2);
      } else if (hardEventState === "active") {
        let secondsLeft = Math.ceil(hardModeCountdown / 60);
        ctx.font = "40px 'Press Start 2P'";
        ctx.fillStyle = "rgba(255,0,0,1)";
        ctx.fillText("HARD MODE", canvas.width / 2, canvas.height / 2);
        ctx.font = "20px 'Press Start 2P'";
        ctx.fillText(secondsLeft, canvas.width / 2, canvas.height / 2 + 40);
      } else if (hardEventState === "chill") {
        ctx.font = "40px 'Press Start 2P'";
        ctx.fillStyle = "rgba(0,255,0,1)";
        ctx.fillText("CHILL", canvas.width / 2, canvas.height / 2);
      }
      ctx.restore();
    }

    // Определяем зазор труб в зависимости от режима
    function effectiveGap() {
      return (hardEventState === "active") ? canvas.height * 0.25 : canvas.height * 0.3;
    }

    // Обработчики ввода
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && gameStarted) {
        shadow.velocity = shadow.jump;
      }
    });
    canvas.addEventListener('click', () => {
      if (gameStarted) {
        shadow.velocity = shadow.jump;
      }
    });
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameStarted) {
        shadow.velocity = shadow.jump;
      }
    });
    startBtn.addEventListener('click', () => {
      username = nicknameInput.value || "Player";
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      startGame();
    });
    telegramBtn.addEventListener('click', () => {
      window.open('https://t.me/FlyingSealCoin', '_blank');
    });
    shopBtn.addEventListener('click', () => {
      menu.style.display = 'none';
      shop.style.display = 'flex';
      renderShopItems();
    });
    shopBackBtn.addEventListener('click', () => {
      shop.style.display = 'none';
      menu.style.display = 'flex';
    });
    shareBtn.addEventListener('click', () => {
      const shareText = `Beat my record in FLYING SEAL! My record is ${score}`;
      const shareUrl = "https://t.me/FlyingSealBot/FLYING";
      const telegramShareLink = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(shareText)}`;
      window.open(telegramShareLink, '_blank');
    });
    continueBtn.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      startGame();
    });
    mainMenuBtn.addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      menu.style.display = 'flex';
      gameStarted = false;
    });
    rewardBtn.addEventListener('click', () => {
      let rewardCoins = hardModeCount * 25;
      totalCoins += rewardCoins;
      localStorage.setItem("totalCoins", totalCoins);
      menuTotalCoinsElement.textContent = `Total Coins: ${totalCoins}`;
      hardModeRewardContainer.style.display = 'none';
      alert("You got " + rewardCoins + " coins for Hard Mode!");
    });

    function startGame() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      pipes = [];
      waterDrips = [];
      particles = [];
      coins = [];
      reactionMessages = [];
      glowEffect.active = false;
      // Сброс эвентов
      hardEventState = "waiting";
      nextHardEventTimer = getRandomEventTimer();
      countdownTimer = 0;
      hardModeCountdown = 0;
      chillTimer = 0;
      hardModeCount = 0;
      shadow.y = canvas.height * 0.5;
      shadow.velocity = 0;
      shadowImg.src = originalShadowSrc;
      gameLoop();
    }

    function createPipe() {
      let effective_gap = effectiveGap();
      const gapPosition = Math.random() * (canvas.height - effective_gap - 100) + 50;
      let color = pipeColors[Math.floor(Math.random() * pipeColors.length)];
      let numPoints = 7;
      let topEdge = generateEdgePoints(pipeWidth, numPoints);
      let bottomEdge = generateEdgePoints(pipeWidth, numPoints);
      pipes.push({
        x: canvas.width,
        topHeight: gapPosition,
        bottomY: gapPosition + effective_gap,
        passed: false,
        color: color,
        topEdge: topEdge,
        bottomEdge: bottomEdge
      });
      createCoin(gapPosition);
    }

    function checkCollision(pipe) {
      return (
        shadow.x < pipe.x + pipeWidth &&
        shadow.x + shadow.width > pipe.x &&
        (shadow.y < pipe.topHeight || shadow.y + shadow.height > pipe.bottomY)
      );
    }

    function drawBackground() {
      if (backgroundImg.complete) {
        ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function gameLoop() {
      if (!gameStarted) return;
      
      // Обновление состояний Hard Mode эвента
      if (hardEventState === "waiting") {
        nextHardEventTimer--;
        if (nextHardEventTimer <= 0) {
          hardEventState = "countdown";
          countdownTimer = 3 * 60;
        }
      } else if (hardEventState === "countdown") {
        countdownTimer--;
        if (countdownTimer <= 0) {
          hardEventState = "active";
          hardModeCountdown = 7 * 60;
        }
      } else if (hardEventState === "active") {
        hardModeCountdown--;
        if (hardModeCountdown <= 0) {
          hardEventState = "chill";
          chillTimer = 60;
          hardModeCount++;
        }
      } else if (hardEventState === "chill") {
        chillTimer--;
        if (chillTimer <= 0) {
          hardEventState = "waiting";
          nextHardEventTimer = getRandomEventTimer();
        }
      }
      
      drawBackground();
      shadow.velocity += shadow.gravity;
      shadow.y += shadow.velocity;
      spawnParticle(shadow.x + shadow.width/2, shadow.y + shadow.height/2);
      updateParticles();
      
      if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (canvas.width * 0.5)) {
        createPipe();
      }
      for (let pipe of pipes) {
        pipe.x -= pipeSpeed;
        if (!pipe.passed && pipe.x + pipeWidth < shadow.x) {
          score++;
          pipe.passed = true;

          // Эффекты при достижении определённых очков
          if (score === 10) {
            activateGlow('rgba(0,255,255,0.8)', 20);
            showReaction('wow, 10!');
          } else if (score === 25) {
            activateGlow('rgba(255,0,255,0.8)', 30);
            showReaction('wow, 25!');
          } else if (score === 50) {
            activateGlow('rgba(255,255,0,0.8)', 40);
            showReaction('wow, 50!');
          } else if (score === 75) {
            activateGlow('rgba(0,255,0,0.8)', 50);
            showReaction('wow, 75!');
          } else if (score === 100) {
            activateGlow('rgba(255,0,0,0.8)', 60);
            showReaction('wow, 100!');
          }
        }
        if (checkCollision(pipe) || shadow.y < 0 || shadow.y + shadow.height > canvas.height) {
          gameStarted = false;
          setTimeout(() => {
            saveScore(username, score);
            if (hardModeCount > 0) {
              hardModeCountText.textContent = "Hard Modes completed: " + hardModeCount;
              hardModeRewardContainer.style.display = 'block';
            } else {
              hardModeRewardContainer.style.display = 'none';
            }
            gameOverOverlay.style.display = 'flex';
          }, 1000);
          return;
        }
      }
      coins.forEach(coin => {
        coin.x -= pipeSpeed;
        if (!coin.collected && checkCoinCollision(coin)) {
          coin.collected = true;
          coinCount++;
          totalCoins++;
          localStorage.setItem("totalCoins", totalCoins);
          menuTotalCoinsElement.textContent = `Total Coins: ${totalCoins}`;
        }
      });
      drawCoins();
      drawParticles();

      // Отрисовка тюленя с glow-эффектом
      if (glowEffect.active) {
        ctx.save();
        ctx.shadowColor = glowEffect.color;
        ctx.shadowBlur = glowEffect.intensity;
        ctx.drawImage(shadowImg, shadow.x, shadow.y, shadow.width, shadow.height);
        ctx.restore();
      } else {
        ctx.drawImage(shadowImg, shadow.x, shadow.y, shadow.width, shadow.height);
      }
      
      drawPipes();
      scoreElement.textContent = `Score: ${score}`;
      coinCountElement.textContent = `Coins: ${coinCount}`;
      
      // Отрисовка реакций и эвентов Hard Mode
      drawReactions();
      if (hardEventState !== "waiting") {
        drawHardModeOverlay();
      }
      
      requestAnimationFrame(gameLoop);
    }

    function saveScore(name, points) {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      scores.push({ name, points });
      scores.sort((a, b) => b.points - a.points);
      scores = scores.slice(0, 5);
      localStorage.setItem("scores", JSON.stringify(scores));
      updateLeaderboard();
    }

    function updateLeaderboard() {
      let scores = JSON.parse(localStorage.getItem("scores") || "[]");
      topScoresList.innerHTML = scores.map(s => `<li>${s.name}: ${s.points}</li>`).join("");
    }
    updateLeaderboard();

    // Магазин: отрисовка списка трейлов
    function renderShopItems() {
      shopItemsDiv.innerHTML = "";
      for (let id in trailsConfig) {
        let trail = trailsConfig[id];
        let div = document.createElement("div");
        div.className = "shop-item";
        div.innerHTML = `<strong>${trail.name}</strong><br>
                         Price: ${trail.price} coins<br>`;
        if (purchasedTrails.includes(trail.id)) {
          if (currentTrailId === trail.id) {
            div.innerHTML += `<em>Selected</em>`;
          } else {
            let selectBtn = document.createElement("button");
            selectBtn.textContent = "Select";
            selectBtn.addEventListener("click", () => {
              currentTrailId = trail.id;
              localStorage.setItem("selectedTrail", currentTrailId);
              renderShopItems();
            });
            div.appendChild(selectBtn);
          }
        } else {
          let buyBtn = document.createElement("button");
          buyBtn.textContent = "Buy";
          buyBtn.addEventListener("click", () => {
            if (totalCoins >= trail.price) {
              totalCoins -= trail.price;
              localStorage.setItem("totalCoins", totalCoins);
              menuTotalCoinsElement.textContent = `Total Coins: ${totalCoins}`;
              purchasedTrails.push(trail.id);
              localStorage.setItem("purchasedTrails", JSON.stringify(purchasedTrails));
              renderShopItems();
            } else {
              alert("Not enough coins!");
            }
          });
          div.appendChild(buyBtn);
        }
        shopItemsDiv.appendChild(div);
      }
    }
  </script>
</body>
</html>

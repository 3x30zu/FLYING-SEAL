<!DOCTYPE html>
<html>
<head>
  <title>Flying Seal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <!-- Подключаем шрифт Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* Общие стили для игры */
    * {
      font-family: 'Press Start 2P', cursive;
    }
    html, body {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      background-color: #000;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    body {
      padding-top: env(safe-area-inset-top);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
    }
    /* Canvas с фоновым изображением */
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: block;
      background: url('BACKGROUND/photo_2025-03-12_12-26-18.gif') center/cover no-repeat;
    }
    /* Контейнер для монет (не используется в режиме DUNK) */
    #coinContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    /* Главное меню, профиль и прочее – стандартные стили */
    #menu {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    #menu * {
      text-shadow: 2px 2px 4px #000;
    }
    #menu h1 {
      font-size: 5vw;
      margin-bottom: 10px;
      animation: bounce 2s infinite;
    }
    #greeting {
      font-size: 3vw;
      margin-bottom: 20px;
    }
    #startBtn, #shopBtn {
      padding: 10px 20px;
      font-size: 3vw;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #fff;
      background: #3498db;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer;
      margin-bottom: 15px;
      transition: all 0.1s;
    }
    #telegramBtn {
      margin-bottom: 15px;
      width: 80px;
      height: auto;
      cursor: pointer;
    }
    #score, #coinCount {
      position: absolute;
      color: white;
      font-size: 4vw;
      z-index: 5;
    }
    #score { top: 5%; left: 5%; }
    #coinCount {
      top: 5%;
      right: 5%;
      display: none;
      align-items: center;
    }
    #coinCount img {
      height: 4vw;
      margin-right: 5px;
    }
    .pixelButton {
      padding: 10px 20px;
      font-size: 3vw;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #fff;
      background: #3498db;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer;
      transition: all 0.1s;
      user-select: none;
    }
    button:active {
      box-shadow: 2px 2px 0 #00ffff;
      transform: translate(2px, 2px);
    }
    #shop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(rgba(0,0,0,0.8), rgba(0,0,0,0.8)), url('BACKGROUND/photo_2025-03-12_12-26-18.gif') center/cover no-repeat;
      color: white;
      display: none;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
      padding: 10px;
      z-index: 30;
    }
    #shop h2 { font-size: 5vw; margin-bottom: 20px; }
    #shopBalance { font-size: 3vw; margin-bottom: 20px; }
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      width: 100%;
    }
    .shop-item {
      background: #3498db;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      padding: 5px;
      text-align: center;
      image-rendering: pixelated;
    }
    .shop-item img {
      width: 100%;
      image-rendering: pixelated;
      margin-bottom: 5px;
    }
    .shop-item button { margin-top: 5px; }
    #shop .back-btn {
      margin-top: 20px;
      background: #FF5722;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      font-size: 3vw;
      padding: 10px 20px;
      cursor: pointer;
    }
    #gameOverOverlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 20;
    }
    #pauseMenu {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      text-align: center;
      padding: 20px;
      z-index: 30;
      width: 80%;
      max-width: 400px;
    }
    #modeSelectModal {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 50;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
    }
    #modeSelectModal button {
      padding: 10px 20px;
      font-size: 3vw;
      margin: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #fff;
      background: #3498db;
      border: 4px solid #fff;
      box-shadow: 4px 4px 0 #00ffff;
      cursor: pointer;
      transition: all 0.1s;
    }
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-20px); }
      60% { transform: translateY(-10px); }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="coinContainer"></div>
  
  <!-- Интерфейс профиля и меню (оставьте как есть) -->
  <!-- Например, кнопка профиля -->
  <button id="profileBtn">
    <img id="currentAvatar" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='45' fill='%23ff0000'/></svg>" alt="avatar">
  </button>
  <button id="platformerPauseBtn" style="position: absolute; top: 120px; right: 10px; display: none;">||</button>
  
  <!-- Модальное окно профиля и остальные элементы интерфейса ... (оставьте их без изменений) -->
  
  <!-- Модальное окно выбора режима -->
  <div id="modeSelectModal">
    <h2>Select Mode</h2>
    <button id="flyingModeBtn">FLYING</button>
    <button id="platformerModeBtn">PLATFORMER</button>
    <button id="dunkModeBtn">DUNK</button>
  </div>
  
  <!-- Пропущены остальные блоки (Shop, Game Over, Pause, etc.) – оставьте их как в предыдущей версии -->
  <!-- ... -->
  
  <div id="score"></div>
  <div id="coinCount">
    <img src="BACKGROUND/goldcoin.gif" alt="coin">
    <span id="coinText">0</span>
  </div>
  
  <script>
    // Общие переменные и функции профиля, уровней, прочее – оставьте их без изменений
    let userNickname = localStorage.getItem("userNickname") || "Guest";
    let userAvatar = localStorage.getItem("userAvatar") || "red";
    function updateProfileDisplay() {
      document.getElementById("nicknameDisplay").textContent = userNickname;
      let avatarImg;
      if (userAvatar === "red") {
        avatarImg = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><circle cx='50' cy='50' r='45' fill='%23ff0000'/></svg>";
      } else if (userAvatar === "green") {
        avatarImg = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><rect x='10' y='10' width='80' height='80' fill='%2300ff00'/></svg>";
      } else if (userAvatar === "blue") {
        avatarImg = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><polygon points='50,5 95,95 5,95' fill='%230000ff'/></svg>";
      }
      document.getElementById("currentAvatar").src = avatarImg;
      document.querySelectorAll("#avatarSelection img").forEach(img => {
        if (img.getAttribute("data-avatar") === userAvatar) img.classList.add("selected");
        else img.classList.remove("selected");
      });
    }
    document.getElementById("editNickname").addEventListener("click", () => {
      let newNick = prompt("Enter your new nickname:", userNickname);
      if(newNick !== null && newNick.trim() !== ""){
        userNickname = newNick.trim();
        localStorage.setItem("userNickname", userNickname);
        updateProfileDisplay();
      }
    });
    document.querySelectorAll("#avatarSelection img").forEach(img => {
      img.addEventListener("click", () => {
        userAvatar = img.getAttribute("data-avatar");
        localStorage.setItem("userAvatar", userAvatar);
        updateProfileDisplay();
      });
    });
    document.getElementById("profileBtn").addEventListener("click", () => {
      document.getElementById("profileModal").style.display = "block";
      updateProfileDisplay();
      updateLevelInfoDisplay();
    });
    document.getElementById("closeProfileModal").addEventListener("click", () => {
      document.getElementById("profileModal").style.display = "none";
    });
    let userLevel = parseInt(localStorage.getItem("userLevel") || "0");
    let userXP = parseInt(localStorage.getItem("userXP") || "0");
    const xpThreshold = 100;
    function updateLevelInfoDisplay() {
      document.getElementById("levelText").textContent = "Level: " + userLevel;
      document.getElementById("xpText").textContent = "XP: " + userXP + " / " + xpThreshold;
    }
    function addXP(points) {
      userXP += points;
      while (userXP >= xpThreshold) { userXP -= xpThreshold; userLevel++; }
      localStorage.setItem("userLevel", userLevel);
      localStorage.setItem("userXP", userXP);
      updateLevelInfoDisplay();
    }
    let platformerLevel = 1;
    
    /* Глобальные переменные для всех режимов */
    let pipes = [], pipeSpeed = 2, pipeWidth = 75;
    const pipeImage = new Image(); pipeImage.src = 'BACKGROUND/PIPE.png';
    const platformImage = new Image(); platformImage.src = 'BACKGROUND/platform.png';
    let collisionOffsetLeft = 10, collisionOffsetRight = 10, collisionOffsetTop = 20, collisionOffsetBottom = 20;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const shop = document.getElementById('shop');
    const shopItemsDiv = document.getElementById('shopItems');
    const shopBackBtn = document.getElementById('shopBackBtn');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const shopBtn = document.getElementById('shopBtn');
    const telegramBtn = document.getElementById('telegramBtn');
    const shareBtn = document.getElementById('shareBtn');
    const continueBtn = document.getElementById('continueBtn');
    const mainMenuBtn = document.getElementById('mainMenuBtn');
    const topScoresList = document.getElementById('topScores');
    const hardModeDescription = document.getElementById('hardModeDescription');
    const closeHardModeDesc = document.getElementById('closeHardModeDesc');
    const scoreElement = document.getElementById('score');
    const coinCountElement = document.getElementById('coinCount');
    const modeSelectModal = document.getElementById('modeSelectModal');
    const flyingModeBtn = document.getElementById('flyingModeBtn');
    const platformerModeBtn = document.getElementById('platformerModeBtn');
    const dunkModeBtn = document.getElementById('dunkModeBtn');
    const platformerPauseBtn = document.getElementById('platformerPauseBtn');
    const pauseMenu = document.getElementById("pauseMenu");
    const platformerControls = document.getElementById("platformerControls");
    
    let gameStarted = false, score = 0, coinCount = 0;
    let paused = false;
    let totalCoins = parseInt(localStorage.getItem("totalCoins") || "0");
    let usernameGame = (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe &&
                        window.Telegram.WebApp.initDataUnsafe.user &&
                        window.Telegram.WebApp.initDataUnsafe.user.username)
                        ? window.Telegram.WebApp.initDataUnsafe.user.username 
                        : "Guest";
    let hardModeEnabled = false, selectedMode = "FLYING";
    let purchasedTrails = JSON.parse(localStorage.getItem("purchasedTrails") || '["1"]');
    let currentTrailId = localStorage.getItem("selectedTrail") || "1";
    const standardSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%230000ff'/></svg>";
    const pixelFrostSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%23a0e9ff'/></svg>";
    const neonPulseSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%23ff00ff'/></svg>";
    const retroArcadeSVG = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><rect width='150' height='150' fill='%23ffff00'/></svg>";
    const pipeDesigns = {
      "0": { id: "0", name: "Standard", price: 0, preview: standardSVG, colors: ["#0000ff"], animation: "none" },
      "1": { id: "1", name: "Pixel Frost", price: 25, preview: pixelFrostSVG, colors: ["#a0e9ff"], animation: "blink" },
      "2": { id: "2", name: "Neon Pulse", price: 50, preview: neonPulseSVG, colors: ["#ff00ff"], animation: "pulse" },
      "3": { id: "3", name: "Retro Arcade", price: 100, preview: retroArcadeSVG, colors: ["#ffff00"], animation: "glow" }
    };
    let purchasedPipeDesigns = JSON.parse(localStorage.getItem("purchasedPipeDesigns") || '["0"]');
    let currentPipeDesign = localStorage.getItem("selectedPipeDesign") || (purchasedPipeDesigns.length > 0 ? purchasedPipeDesigns[0] : "0");
    const shopBalance = document.getElementById('shopBalance');
    shopBalance.textContent = `Total Coins: ${totalCoins}`;
    let particles = [], coins = [], reactionMessages = [];
    const sealJump = new Image(); sealJump.src = 'BACKGROUND/seal jump.png';
    const sealFall = new Image(); sealFall.src = 'BACKGROUND/seal fall.png';
    let nerpaImg = sealJump;
    
    /* ========== Режим DUNK (SLINGSHOT + UPWARD GAME) ========== */
    let dunkGameStarted = false;
    let dunkLaunched = false;   // мяч запущен
    let dunkDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragCurrent = { x: 0, y: 0 };
    let dunkScore = 0;
    let dunkPlayer = null;
    let dunkHoops = [];  // массив колец
    const hoopRadius = 40;        // радиус кольца
    const hoopInnerRadius = hoopRadius - 8;  // внутренняя зона кольца для успешного данка
    let cameraOffset = 0;         // сдвиг для имитации движения вверх
    
    // Создание нового кольца. Новое кольцо появляется выше предыдущего или заданной позиции.
    function spawnHoop(y) {
      let hoop = {
        x: canvas.width * 0.7 + (Math.random() - 0.5) * 50,
        y: y,
        radius: hoopRadius,
        scored: false  // флаг, что данк для этого кольца уже засчитан
      };
      dunkHoops.push(hoop);
    }
    
    // Инициализация режима DUNK
    function startDunkMode() {
      dunkGameStarted = true;
      dunkLaunched = false;
      dunkDragging = false;
      dunkScore = 0;
      cameraOffset = 0;
      dunkHoops = [];
      // Устанавливаем мяч выше нижней границы, чтобы он «висел» до начала броска
      dunkPlayer = {
        x: canvas.width * 0.2,
        y: canvas.height - 150,  // можно изменить для регулировки высоты стартовой позиции
        radius: canvas.width * 0.05,
        vx: 0,
        vy: 0,
        gravity: 0.5,
        rotation: 0
      };
      // Создаём первое кольцо немного выше мяча
      spawnHoop(dunkPlayer.y - 200);
      // Добавляем слушатели для drag-and-release (мышь и touch)
      canvas.addEventListener("mousedown", dunkMouseDown);
      canvas.addEventListener("mousemove", dunkMouseMove);
      canvas.addEventListener("mouseup", dunkMouseUp);
      canvas.addEventListener("touchstart", dunkTouchStart, {passive: false});
      canvas.addEventListener("touchmove", dunkTouchMove, {passive: false});
      canvas.addEventListener("touchend", dunkTouchEnd, {passive: false});
      dunkGameLoop();
    }
    
    // Основной цикл режима DUNK
    function dunkGameLoop() {
      if (!dunkGameStarted || paused) return;
      clearCanvas();
      
      // Если мяч запущен – обновляем физику
      if (dunkLaunched) {
        dunkPlayer.vy += dunkPlayer.gravity;
        dunkPlayer.x += dunkPlayer.vx;
        dunkPlayer.y += dunkPlayer.vy;
        dunkPlayer.rotation += 0.1;
      }
      
      // Отскок от стен
      if (dunkPlayer.x - dunkPlayer.radius < 0) {
        dunkPlayer.x = dunkPlayer.radius;
        dunkPlayer.vx = -dunkPlayer.vx;
      }
      if (dunkPlayer.x + dunkPlayer.radius > canvas.width) {
        dunkPlayer.x = canvas.width - dunkPlayer.radius;
        dunkPlayer.vx = -dunkPlayer.vx;
      }
      
      // Рисуем кольца (учитываем сдвиг камеры)
      for (let hoop of dunkHoops) {
        drawHoop(hoop);
        // Проверяем успешный данк: если расстояние от центра мяча до центра кольца меньше внутренней границы и мяч движется вниз
        if (!hoop.scored && isDunkSuccessful(hoop, dunkPlayer)) {
          hoop.scored = true;
          dunkScore++;
          showReaction("Dunk! Score: " + dunkScore);
          // Поднимаем мяч (имитируем эффект удачного броска)
          dunkPlayer.vy = -10;
          // Если мяч поднимается выше центра экрана, сдвигаем все объекты вниз
          if (dunkPlayer.y < canvas.height / 2) {
            let shift = (canvas.height / 2) - dunkPlayer.y;
            cameraOffset += shift;
            dunkPlayer.y += shift;
            for (let hoop of dunkHoops) {
              hoop.y += shift;
            }
          }
          // Спавним новое кольцо выше самого верхнего
          let highest = Math.min(...dunkHoops.map(h => h.y));
          spawnHoop(highest - 200);
        }
        // Если происходит столкновение с ободом (и мяч не проходит внутрь), инвертируем горизонтальную скорость
        else if (isRimCollision(hoop, dunkPlayer)) {
          dunkPlayer.vx = -dunkPlayer.vx * 0.8;
        }
      }
      
      // Рисуем прицел, если происходит перетаскивание
      if (dunkDragging) {
        ctx.save();
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(dunkPlayer.x, dunkPlayer.y);
        ctx.lineTo(dragCurrent.x, dragCurrent.y);
        ctx.stroke();
        ctx.restore();
      }
      
      drawDunkBall();
      
      // Если мяч опустился ниже экрана – игра завершается
      if (dunkPlayer.y - dunkPlayer.radius > canvas.height) {
        dunkGameStarted = false;
        canvas.removeEventListener("mousedown", dunkMouseDown);
        canvas.removeEventListener("mousemove", dunkMouseMove);
        canvas.removeEventListener("mouseup", dunkMouseUp);
        canvas.removeEventListener("touchstart", dunkTouchStart);
        canvas.removeEventListener("touchmove", dunkTouchMove);
        canvas.removeEventListener("touchend", dunkTouchEnd);
        addXP(dunkScore);
        setTimeout(() => { gameOverOverlay.style.display = 'block'; }, 1000);
        return;
      }
      
      scoreElement.textContent = `Dunk Score: ${dunkScore}`;
      requestAnimationFrame(dunkGameLoop);
    }
    
    // Обработчики drag-and-release мышью
    function dunkMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const dist = Math.hypot(mouseX - dunkPlayer.x, mouseY - dunkPlayer.y);
      if (dist <= dunkPlayer.radius) {
        dunkDragging = true;
        dragStart = { x: mouseX, y: mouseY };
        dragCurrent = { x: mouseX, y: mouseY };
        dunkLaunched = false;
        dunkPlayer.vx = 0;
        dunkPlayer.vy = 0;
      }
    }
    function dunkMouseMove(e) {
      if (dunkDragging) {
        const rect = canvas.getBoundingClientRect();
        dragCurrent = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
    }
    function dunkMouseUp(e) {
      if (dunkDragging) {
        dunkDragging = false;
        const dx = dragStart.x - dragCurrent.x;
        const dy = dragStart.y - dragCurrent.y;
        dunkPlayer.vx = dx * 0.2;
        dunkPlayer.vy = dy * 0.2;
        dunkLaunched = true;
        // Сбрасываем флаг успешного данка для всех колец
        for (let hoop of dunkHoops) {
          hoop.scored = false;
        }
      }
    }
    // Аналогичные обработчики для touch
    function dunkTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;
      const dist = Math.hypot(touchX - dunkPlayer.x, touchY - dunkPlayer.y);
      if (dist <= dunkPlayer.radius) {
        dunkDragging = true;
        dragStart = { x: touchX, y: touchY };
        dragCurrent = { x: touchX, y: touchY };
        dunkLaunched = false;
        dunkPlayer.vx = 0;
        dunkPlayer.vy = 0;
      }
    }
    function dunkTouchMove(e) {
      if (dunkDragging) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        dragCurrent = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
      }
    }
    function dunkTouchEnd(e) {
      if (dunkDragging) {
        e.preventDefault();
        dunkDragging = false;
        const dx = dragStart.x - dragCurrent.x;
        const dy = dragStart.y - dragCurrent.y;
        dunkPlayer.vx = dx * 0.2;
        dunkPlayer.vy = dy * 0.2;
        dunkLaunched = true;
        for (let hoop of dunkHoops) {
          hoop.scored = false;
        }
      }
    }
    
    // Отрисовка кольца
    function drawHoop(hoop) {
      ctx.save();
      ctx.lineWidth = 5;
      ctx.strokeStyle = "#FF4500";
      ctx.beginPath();
      ctx.arc(hoop.x, hoop.y, hoop.radius, Math.PI * 0.1, Math.PI * 0.9, false);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(hoop.x + hoop.radius * Math.cos(Math.PI * 0.1), hoop.y - hoop.radius * Math.sin(Math.PI * 0.1));
      ctx.lineTo(hoop.x + hoop.radius * Math.cos(Math.PI * 0.1), hoop.y - hoop.radius * Math.sin(Math.PI * 0.1) - 50);
      ctx.stroke();
      ctx.restore();
    }
    
    // Отрисовка мяча
    function drawDunkBall() {
      ctx.save();
      ctx.translate(dunkPlayer.x, dunkPlayer.y);
      ctx.rotate(dunkPlayer.rotation);
      let ballSize = dunkPlayer.radius * 2;
      ctx.drawImage(nerpaImg, -dunkPlayer.radius, -dunkPlayer.radius, ballSize, ballSize);
      ctx.restore();
    }
    
    // Проверка успешного данка: если расстояние от центра мяча до центра кольца меньше hoopInnerRadius и мяч движется вниз
    function isDunkSuccessful(hoop, ball) {
      let dist = Math.hypot(ball.x - hoop.x, ball.y - hoop.y);
      return (dist < hoopInnerRadius && ball.vy > 0);
    }
    
    // Проверка столкновения с ободом кольца
    function isRimCollision(hoop, ball) {
      let dist = Math.hypot(ball.x - hoop.x, ball.y - hoop.y);
      return (Math.abs(dist - hoop.radius) < 5 && ball.vy <= 0);
    }
    
    /* Функции для режимов FLYING и PLATFORMER (оставлены как заглушки или без изменений) */
    let shadow = null;
    function startFlyingMode() {
      gameStarted = true;
      score = 0;
      coinCount = 0;
      coins = [];
      pipes = [];
      particles = [];
      reactionMessages = [];
      scoreElement.style.display = 'block';
      coinCountElement.style.display = 'flex';
      nerpaImg = sealJump;
      shadow = {
        x: canvas.width * 0.1,
        y: canvas.height * 0.5,
        width: canvas.width * 0.1,
        height: canvas.width * 0.1,
        velocity: 0,
        gravity: 0.35,
        jump: -6
      };
      flyingGameLoop();
    }
    function flyingGameLoop() {
      // Реализация FLYING режима (оставьте как в предыдущем коде)
    }
    function startPlatformerLevel() {
      // Реализация PLATFORMER режима (оставьте как в предыдущем коде)
    }
    
    /* Обработчики главного меню */
    document.getElementById('startBtn').addEventListener('click', () => {
      modeSelectModal.style.display = 'flex';
      document.getElementById('platformerControls').style.display = 'none';
    });
    document.getElementById('flyingModeBtn').addEventListener('click', () => {
      modeSelectModal.style.display = 'none';
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      document.getElementById('platformerPauseBtn').style.display = 'none';
      coinCountElement.style.display = 'flex';
      hideProfileButton();
      document.getElementById('platformerControls').style.display = 'none';
      selectedMode = "FLYING";
      startFlyingMode();
    });
    document.getElementById('platformerModeBtn').addEventListener('click', () => {
      modeSelectModal.style.display = 'none';
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      document.getElementById('platformerPauseBtn').style.display = 'block';
      coinCountElement.style.display = 'none';
      hideProfileButton();
      document.getElementById('platformerControls').style.display = 'flex';
      selectedMode = "PLATFORMER";
      startPlatformerLevel();
    });
    document.getElementById('dunkModeBtn').addEventListener('click', () => {
      modeSelectModal.style.display = 'none';
      menu.style.display = 'none';
      gameOverOverlay.style.display = 'none';
      hideProfileButton();
      selectedMode = "DUNK";
      startDunkMode();
    });
    document.getElementById('telegramBtn').addEventListener('click', () => {
      window.open('https://t.me/FlyingSealCoin', '_blank');
    });
    document.getElementById('shopBtn').addEventListener('click', () => {
      menu.style.display = 'none';
      shop.style.display = 'flex';
      renderShopItems();
    });
    document.getElementById('shopBackBtn').addEventListener('click', () => {
      shop.style.display = 'none';
      menu.style.display = 'flex';
      document.getElementById('platformerControls').style.display = 'none';
    });
    document.getElementById('shareBtn').addEventListener('click', () => {
      const shareText = `Beat my record in FLYING SEAL! My record is ${score}`;
      const shareUrl = "https://t.me/FlyingSealBot/FLYING";
      const telegramShareLink = `https://t.me/share/url?url=${encodeURIComponent(shareUrl)}&text=${encodeURIComponent(shareText)}`;
      window.open(telegramShareLink, '_blank');
    });
    document.getElementById('continueBtn').addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      if(selectedMode === "FLYING") { startFlyingMode(); }
      else if(selectedMode === "PLATFORMER") { startPlatformerLevel(); }
      else if(selectedMode === "DUNK") { startDunkMode(); }
    });
    document.getElementById('mainMenuBtn').addEventListener('click', () => {
      gameOverOverlay.style.display = 'none';
      menu.style.display = 'flex';
      showProfileButton();
      document.getElementById('platformerPauseBtn').style.display = 'none';
      document.getElementById('platformerControls').style.display = 'none';
      gameStarted = false;
      // Останавливаем все режимы
      dunkGameStarted = false;
      paused = false;
      clearCanvas();
      // Сбрасываем данные
      currentPlatforms = [];
      pipes = [];
      coins = [];
      score = 0;
      coinCount = 0;
      addXP(score);
    });
    document.getElementById('closeHardModeDesc').addEventListener('click', () => {
      hardModeDescription.style.display = 'none';
    });
    document.getElementById('platformerPauseBtn').addEventListener('click', () => {
      paused = true;
      pauseMenu.style.display = 'block';
    });
    const resumeBtn = document.getElementById('resumeBtn');
    resumeBtn.addEventListener('click', () => {
      paused = false;
      pauseMenu.style.display = 'none';
      if (selectedMode === "FLYING") { flyingGameLoop(); }
      else if (selectedMode === "PLATFORMER") { platformerLoop(currentPlatforms); }
      else if (selectedMode === "DUNK") { dunkGameLoop(); }
    });
    const exitBtn = document.getElementById('exitBtn');
    exitBtn.addEventListener('click', () => {
      paused = false;
      pauseMenu.style.display = 'none';
      menu.style.display = 'flex';
      showProfileButton();
      document.getElementById('platformerPauseBtn').style.display = 'none';
      document.getElementById('platformerControls').style.display = 'none';
      gameStarted = false;
      dunkGameStarted = false;
      clearCanvas();
      currentPlatforms = [];
      pipes = [];
      coins = [];
      score = 0;
      coinCount = 0;
    });
    
    // Функции для обновления монет и частиц (оставляем без изменений)
    function spawnParticle(x, y) {
      particles.push({ x: x, y: y, size: Math.random() * 4 + 4, alpha: 1, decay: Math.random() * 0.03 + 0.01 });
    }
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.alpha -= p.decay;
        p.x -= 0.5;
        if (p.alpha <= 0) { particles.splice(i, 1); }
      }
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    function updateShadowImage() { nerpaImg = shadow.velocity < 0 ? sealJump : sealFall; }
    function hideProfileButton() { document.getElementById('profileBtn').style.display = 'none'; }
    function showProfileButton() { document.getElementById('profileBtn').style.display = 'block'; }
    
    // Обработчики для PLATFORMER и FLYING режимов – оставляем без изменений (или их реализации вы можете добавить по образцу ранее)
    
    // Функция resizeCanvas
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // Остальной код для FLYING и PLATFORMER (заглушки или оставьте вашу предыдущую реализацию)
    // ...
    
    // Функция renderShopItems – оставьте вашу реализацию магазина
    
  </script>
</body>
</html>
